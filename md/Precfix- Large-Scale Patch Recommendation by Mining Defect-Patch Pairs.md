# Precfix: Large-Scale Patch Recommendation by Mining Defect-Patch Pairs

## ABSTRACT

Patch recommendation is the process of identifying errors in software systems and suggesting suitable fixes for them. Patch recommendation can significantly improve developer productivity by reducing both the debugging and repairing time. Existing techniques usually rely on complete test suites and detailed debugging reports, which are often absent in practical industrial settings. In this paper, we propose Precfix, a pragmatic approach targeting large-scale industrial codebase and making recommendations based on previously observed debugging activities. Precfix collects defect-patch pairs from development histories, performs clustering, and extracts generic reusable patching patterns as recommendations. We conducted experimental study on an industrial codebase with 10K projects involving diverse defect patterns. We managed to extract 3K templates of defect-patch pairs, which have been successfully applied to the entire codebase. Our approach is able to make recommendations within milliseconds and achieves a false positive rate of 22% confirmed by manual review. The majority (10/12) of the interviewed developers appreciated Precfix, which has been rolled out to Alibaba to support various critical businesses.

è¡¥ä¸æ¨èæ˜¯æŒ‡è¯†åˆ«è½¯ä»¶ç³»ç»Ÿä¸­çš„é”™è¯¯å¹¶å»ºè®®é€‚å½“çš„è¡¥ä¸çš„è¿‡ç¨‹ã€‚é€šè¿‡å‡å°‘è°ƒè¯•å’Œä¿®å¤æ—¶é—´ï¼Œè¡¥ä¸æ¨èå¯ä»¥æ˜¾è‘—æé«˜å¼€å‘äººå‘˜çš„å·¥ä½œæ•ˆç‡ã€‚ç°æœ‰çš„æŠ€æœ¯é€šå¸¸ä¾èµ–äºå®Œæ•´çš„æµ‹è¯•å¥—ä»¶å’Œè¯¦ç»†çš„è°ƒè¯•æŠ¥å‘Šï¼Œè€Œè¿™äº›åœ¨å®é™…çš„å·¥ä¸šç¯å¢ƒä¸­é€šå¸¸æ˜¯ä¸å­˜åœ¨çš„ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æå‡ºPrecfixï¼Œè¿™æ˜¯ä¸€ç§é’ˆå¯¹å¤§å‹å·¥ä¸šä»£ç åº“çš„å®ç”¨æ–¹æ³•ï¼Œå¹¶æ ¹æ®ä¹‹å‰è§‚å¯Ÿåˆ°çš„è°ƒè¯•æ´»åŠ¨æå‡ºå»ºè®®ã€‚Precfixä»å¼€å‘å†å²ä¸­æ”¶é›†ç¼ºé™·-è¡¥ä¸å¯¹ï¼Œæ‰§è¡Œé›†ç¾¤ï¼Œå¹¶æå–é€šç”¨çš„å¯é‡ç”¨è¡¥ä¸æ¨¡å¼ä½œä¸ºå»ºè®®ã€‚æˆ‘ä»¬å¯¹ä¸€ä¸ªåŒ…å«ä¸åŒç¼ºé™·æ¨¡å¼çš„10Ké¡¹ç›®çš„å·¥ä¸šä»£ç åº“è¿›è¡Œäº†å®éªŒç ”ç©¶ã€‚æˆ‘ä»¬æˆåŠŸåœ°æå–äº†ç¼ºé™·-è¡¥ä¸å¯¹çš„3Kæ¨¡æ¿ï¼Œå¹¶æˆåŠŸåœ°åº”ç”¨äºæ•´ä¸ªä»£ç åº“ã€‚æˆ‘ä»¬çš„æ–¹æ³•èƒ½å¤Ÿåœ¨å‡ æ¯«ç§’å†…ç»™å‡ºå»ºè®®ï¼Œå¹¶é€šè¿‡äººå·¥æ£€æŸ¥è·å¾—22%çš„è¯¯é˜³æ€§ç‡ã€‚å¤§å¤šæ•°(10/12)å—è®¿å¼€å‘è€…å¯¹Precfixè¡¨ç¤ºèµèµï¼Œè¯¥å…¬å¸å·²ç»å‘é˜¿é‡Œå·´å·´æ¨å‡ºäº†Precfixï¼Œä»¥æ”¯æŒå„ç§å…³é”®ä¸šåŠ¡ã€‚

## 1 INTRODUCTION

Patch recommendation is the process of identifying errors in software systems and suggesting suitable fixes. Recent studies show that on average 49.9% of software developersâ€™ time has been spent in debugging and about half of the development costs are associated with debugging and patching [5, 11, 49]. Automated patch recommendation can significantly reduce developersâ€™ debugging efforts and the overall development costs, improving software quality and system reliability.

[
[5] Tom Britton, Lisa Jeng, Graham Carver, Paul Cheak, and Tomer Katzenellenbogen. 2013. Reversible Debugging Software. Technical Report. Judge Business School, University of Cambridge. 
[11] Luca Gazzola, Daniela Micucci, and Leonardo Mariani. 2019. Automatic Software Repair: A Survey. Transactions on Software Engineering 45, 1 (2019), 34â€“67.
[49] Undo Software. 2014. Increasing Software Development Productivity with Reversible Debugging.
]

è¡¥ä¸æ¨èæ˜¯è¯†åˆ«è½¯ä»¶ç³»ç»Ÿä¸­çš„é”™è¯¯å¹¶å»ºè®®é€‚å½“ä¿®å¤çš„è¿‡ç¨‹ã€‚æœ€è¿‘çš„ç ”ç©¶è¡¨æ˜ï¼Œè½¯ä»¶å¼€å‘äººå‘˜å¹³å‡49.9%çš„æ—¶é—´èŠ±åœ¨äº†è°ƒè¯•ä¸Šï¼Œå¤§çº¦ä¸€åŠçš„å¼€å‘æˆæœ¬ä¸è°ƒè¯•å’Œæ‰“è¡¥ä¸æœ‰å…³[5,11,49]ã€‚è‡ªåŠ¨è¡¥ä¸æ¨èå¯ä»¥æ˜¾è‘—å‡å°‘å¼€å‘äººå‘˜çš„è°ƒè¯•å·¥ä½œå’Œæ•´ä½“å¼€å‘æˆæœ¬ï¼Œæé«˜è½¯ä»¶è´¨é‡å’Œç³»ç»Ÿå¯é æ€§ã€‚

Recommending patches automatically is a challenging task, especially for large-scale industrial codebase. Many state-of-the-art techniques from the literature make assumptions on the existence of auxiliary development artifacts such as complete test suites and detailed issue tracking and debugging reports, which may not be readily available in the day-to-day development environment. To better understand the specific challenges in applying existing techniques in the development environment of Alibaba, we investigated the development practices and the entire codebase at Alibaba, ended up extracting a sample benchmark set which includes over 10,000 software projects, spanning over 15 million commits and 30 million files. We have made the following observations through the study.

è‡ªåŠ¨æ¨èè¡¥ä¸æ˜¯ä¸€ä¸ªå…·æœ‰æŒ‘æˆ˜æ€§çš„ä»»åŠ¡ï¼Œç‰¹åˆ«æ˜¯å¯¹äºå¤§è§„æ¨¡çš„å·¥ä¸šä»£ç åº“ã€‚è®¸å¤šæ¥è‡ªæ–‡çŒ®çš„æœ€æ–°æŠ€æœ¯å¯¹è¾…åŠ©å¼€å‘å·¥ä»¶çš„å­˜åœ¨åšå‡ºäº†å‡è®¾ï¼Œä¾‹å¦‚å®Œæ•´çš„æµ‹è¯•å¥—ä»¶å’Œè¯¦ç»†çš„é—®é¢˜è·Ÿè¸ªå’Œè°ƒè¯•æŠ¥å‘Šï¼Œè¿™äº›åœ¨æ—¥å¸¸çš„å¼€å‘ç¯å¢ƒä¸­å¯èƒ½å¹¶ä¸å®¹æ˜“è·å¾—ã€‚ä¸ºäº†æ›´å¥½åœ°ç†è§£åœ¨é˜¿é‡Œå·´å·´çš„å¼€å‘ç¯å¢ƒä¸­åº”ç”¨ç°æœ‰æŠ€æœ¯æ‰€é¢ä¸´çš„å…·ä½“æŒ‘æˆ˜ï¼Œæˆ‘ä»¬è°ƒæŸ¥äº†é˜¿é‡Œå·´å·´çš„å¼€å‘å®è·µå’Œæ•´ä¸ªä»£ç åº“ï¼Œæœ€ç»ˆæå–äº†ä¸€ä¸ªæ ·æœ¬åŸºå‡†é›†ï¼Œå…¶ä¸­åŒ…æ‹¬è¶…è¿‡10,000ä¸ªè½¯ä»¶é¡¹ç›®ï¼Œè¶…è¿‡1,500ä¸‡ä»½æäº¤å’Œ3,000ä¸‡ä»½æ–‡ä»¶ã€‚æˆ‘ä»¬é€šè¿‡ç ”ç©¶å¾—å‡ºäº†ä»¥ä¸‹è§‚å¯Ÿç»“æœã€‚

First, the project codebase often has insufficient documentation and manual labeling of defects and patches is hardly possible, which makes accurate patch mining and generation difficult. For example, recent studies proposed approaches based on clone detection [36], patch mining [17], information retrieval [59], and machine learning [6, 26] for fault localization and repair, which naturally require a large amount of labeled data. On the other hand, existing methods for automatic defect and patch identification suffer from inaccuracy. For instance, the SZZ algorithm [48] only achieves less than 25% accuracy on our benchmark set, which is mainly due to the inaccurate/missing bug reports and log messages.

[
[36] Mathieu Nayrolles and Abdelwahab Hamou-Lhadj. 2018. CLEVER: Combining Code Metrics with Clone Detection for Just-In-Time Fault Prevention and Resolution in Large Industrial Projects. In International Conference on Mining Software Repositories. 153â€“164.
[17] Jiajun Jiang, Yingfei Xiong, Hongyu Zhang, Qing Gao, and Xiangqun Chen. 2018. Shaping Program Repair Space with Existing Patches and Similar Code. In International Symposium on Software Testing and Analysis. 298â€“309.
[59] Jian Zhou, Hongyu Zhang, and David Lo. 2012. Where Should the Bugs be Fixed? More Accurate Information Retrieval-Based Bug Localization Based on Bug Reports. In International Conference on Software Engineering. 14â€“24.
[6] Zimin Chen, Steve Kommrusch, Michele Tufano, Louis-NoÃ«l Pouchet, Denys Poshyvanyk, and Martin Monperrus. 2018. SequenceR: Sequence-to-Sequence Learning for End-to-End Program Repair. arXiv:cs.SE/1901.01808
[26] Jian Li, Pinjia He, Jieming Zhu, and Michael R. Lyu. 2017. Software Defect Prediction via Convolutional Neural Network. In International Conference on Software Quality, Reliability and Security. 318â€“328. 
[48] Jacek Åšliwerski, Thomas Zimmermann, and Andreas Zeller. 2005. When do Changes Induce Fixes?. In International Conference on Mining Software Repositories. 1â€“5.
]

é¦–å…ˆï¼Œé¡¹ç›®çš„ä»£ç åº“é€šå¸¸æ²¡æœ‰è¶³å¤Ÿçš„æ–‡æ¡£ï¼Œå¹¶ä¸”å¾ˆéš¾æ‰‹å·¥æ ‡è®°ç¼ºé™·å’Œè¡¥ä¸ï¼Œè¿™ä½¿å¾—ç²¾ç¡®çš„è¡¥ä¸æŒ–æ˜å’Œç”Ÿæˆå˜å¾—éå¸¸å›°éš¾ã€‚ä¾‹å¦‚ï¼Œæœ€è¿‘çš„ç ”ç©¶æå‡ºäº†åŸºäºå…‹éš†æ£€æµ‹[36]ã€patchæŒ–æ˜[17]ã€ä¿¡æ¯æ£€ç´¢[59]å’Œæœºå™¨å­¦ä¹ [6,26]çš„æ•…éšœå®šä½å’Œä¿®å¤æ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•è‡ªç„¶éœ€è¦å¤§é‡çš„æ ‡è®°æ•°æ®ã€‚å¦ä¸€æ–¹é¢ï¼Œç°æœ‰çš„ç¼ºé™·è‡ªåŠ¨è¯†åˆ«å’Œè¡¥ä¸è¯†åˆ«æ–¹æ³•ä¹Ÿå­˜åœ¨ä¸å‡†ç¡®çš„é—®é¢˜ã€‚ä¾‹å¦‚ï¼ŒSZZç®—æ³•[48]åœ¨æˆ‘ä»¬çš„åŸºå‡†é›†ä¸Šåªèƒ½è¾¾åˆ°ä¸åˆ°25%çš„å‡†ç¡®ç‡ï¼Œè¿™ä¸»è¦æ˜¯ç”±äºé”™è¯¯æŠ¥å‘Šå’Œæ—¥å¿—æ¶ˆæ¯ä¸å‡†ç¡®/ç¼ºå¤±é€ æˆçš„ã€‚

Second, the patch recommendation process has to be highly responsive in suggesting patches, in order to be useful in the everyday development routine. However, many existing fault localization and patch generation techniques require dynamic execution of test suites. For example, the spectrum-based [1, 18] and mutationbased [35, 40] fault localization techniques both assume strong test cases and utilize test execution results to identify defects. The generate-and-validate approaches [7, 22, 32] for patch generation search for candidate patches and validate their correctness using test suites. The problem with these techniques is that the test suites in our benchmark set may not be complete and the test execution often takes significant amount of time, making responsive online patch recommendation impossible.

[
[1] Rui Abreu, Peter Zoeteweij, and Arjan JC Van Gemund. 2007. On the Accuracy of Spectrum-Based Fault Localization. In Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION. 89â€“98. 
[18] James A Jones and Mary Jean Harrold. 2005. Empirical Evaluation of the Tarantula Automatic Fault-Localization Technique. In International Conference on Automated Software Engineering. 273â€“282.
[35] Seokhyeon Moon, Yunho Kim, Moonzoo Kim, and Shin Yoo. 2014. Ask the Mutants: Mutating Faulty Programs for Fault Localization. In International Conference on Software Testing, Verification and Validation. 153â€“162.
[40] Mike Papadakis and Yves Le Traon. 2015. Metallaxis-FL: Mutation-Based Fault Localization. Software Testing, Verification and Reliability 25, 5-7 (2015), 605â€“628. 
[7] Valentin Dallmeier, Andreas Zeller, and Bertrand Meyer. 2009. Generating Fixes From Object Behavior Anomalies. In International Conference on Automated Software Engineering. 550â€“554.
[22] Dongsun Kim, Jaechang Nam, Jaewoo Song, and Sunghun Kim. 2013. Automatic Patch Generation Learned from Human-Written Patches. In International Conference on Software Engineering. 802â€“811. 
[32] Fan Long and Martin Rinard. 2016. Automatic Patch Generation by Learning Correct Code. In Symposium on Principles of Programming Languages. 298â€“312.
]

å…¶æ¬¡ï¼Œè¡¥ä¸æ¨èè¿‡ç¨‹å¿…é¡»åœ¨å»ºè®®è¡¥ä¸æ—¶å…·æœ‰é«˜åº¦çš„å“åº”æ€§ï¼Œä»¥ä¾¿åœ¨æ—¥å¸¸å¼€å‘ä¾‹ç¨‹ä¸­å‘æŒ¥ä½œç”¨ã€‚ç„¶è€Œï¼Œè®¸å¤šç°æœ‰çš„æ•…éšœå®šä½å’Œè¡¥ä¸ç”ŸæˆæŠ€æœ¯éœ€è¦æµ‹è¯•å¥—ä»¶çš„åŠ¨æ€æ‰§è¡Œã€‚ä¾‹å¦‚ï¼ŒåŸºäºè°±çš„[1,18]å’ŒåŸºäºçªå˜çš„[35,40]æ•…éšœå®šä½æŠ€æœ¯éƒ½å‡è®¾äº†å¼ºå¤§çš„æµ‹è¯•ç”¨ä¾‹ï¼Œå¹¶åˆ©ç”¨æµ‹è¯•æ‰§è¡Œç»“æœæ¥è¯†åˆ«ç¼ºé™·ã€‚ç”Ÿæˆå’ŒéªŒè¯è¡¥ä¸çš„æ–¹æ³•[7,22,32]æœç´¢å€™é€‰è¡¥ä¸å¹¶ä½¿ç”¨æµ‹è¯•å¥—ä»¶éªŒè¯å®ƒä»¬çš„æ­£ç¡®æ€§ã€‚è¿™äº›æŠ€æœ¯çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬çš„åŸºå‡†æµ‹è¯•é›†ä¸­çš„æµ‹è¯•å¥—ä»¶å¯èƒ½ä¸å®Œæ•´ï¼Œæµ‹è¯•æ‰§è¡Œé€šå¸¸éœ€è¦å¤§é‡æ—¶é—´ï¼Œè¿™ä½¿å¾—å“åº”æ€§åœ¨çº¿è¡¥ä¸æ¨èå˜å¾—ä¸å¯èƒ½ã€‚

Finally, many fault localization and patch generation techniques focus on specific domains such as concurrency [30, 31], HTML content generation [46], and memory leaks [10]. Yet, our benchmark set covers a variety of business scenarios from diverse application domains, including e-commerce, logistics, finance, cloud computing, etc. These domain-specific techniques may work well in their targeted cases, but they are often not generalizable to the diverse applications from the company codebase.

[
[30] Haopeng Liu, Yuxi Chen, and Shan Lu. 2016. Understanding and Generating High Quality Patches for Concurrency Bugs. In Symposium on Foundations of Software Engineering. 715â€“726.
[31] Peng Liu, Omer Tripp, and Charles Zhang. 2014. Grail: Context-Aware Fixing of Concurrency Bugs. In Symposium on Foundations of Software Engineering. 318â€“329.
[46] Hesam Samimi, Max Schafer, Shay Artzi, Todd Millstein, Frank Tip, and Laurie Hendren. 2012. Automated Repair of HTML Generation Errors in PHP Applications using String Constraint Solving. In International Conference on Software Engineering. 277â€“287.
[10] Qing Gao, Yingfei Xiong, Yaqing Mi, Lu Zhang, Weikun Yang, Zhaoping Zhou, Bing Xie, and Hong Mei. 2015. Safe Memory-Leak Fixing For C Programs. In International Conference on Software Engineering. 459â€“470.
]

æœ€åï¼Œè®¸å¤šæ•…éšœå®šä½å’Œè¡¥ä¸ç”ŸæˆæŠ€æœ¯éƒ½é›†ä¸­åœ¨ç‰¹å®šçš„é¢†åŸŸï¼Œå¦‚å¹¶å‘æ€§[30,31]ã€HTMLå†…å®¹ç”Ÿæˆ[46]å’Œå†…å­˜æ³„æ¼[10]ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬çš„åŸºå‡†é›†æ¶µç›–äº†æ¥è‡ªä¸åŒåº”ç”¨é¢†åŸŸçš„å„ç§ä¸šåŠ¡åœºæ™¯ï¼ŒåŒ…æ‹¬ç”µå­å•†åŠ¡ã€ç‰©æµã€é‡‘èã€äº‘è®¡ç®—ç­‰ã€‚è¿™äº›é¢†åŸŸç‰¹å®šçš„æŠ€æœ¯å¯èƒ½åœ¨å®ƒä»¬çš„ç›®æ ‡æ¡ˆä¾‹ä¸­å·¥ä½œå¾—å¾ˆå¥½ï¼Œä½†æ˜¯å®ƒä»¬é€šå¸¸ä¸èƒ½æ¨å¹¿åˆ°æ¥è‡ªå…¬å¸ä»£ç åº“çš„å„ç§åº”ç”¨ç¨‹åºã€‚

The above mentioned characteristics of the codebase and development environment make the adoption of existing techniques unsuitable. In this paper, we propose a pragmatic patch recommendation approach Precfix, with customized improvements in terms of both the precision and efficiency when applied on large-scale industrial codebase. First, Precfix does not rely on labeled defects or patches, which are difficult to obtain in practice. Instead, we automatically mine a large number of defect-patch pairs from historical changes. To improve the accuracy of the mining results, we introduce optimizations which take into account the characteristics of typical developer behaviors in committing bug fixing changes. We also allow developers in the loop to provide feedback on the quality of the recommended patches, and the feedback is used to improve the precision of future recommendations. Second, since the defects and patches are mined from the entire company codebase and we use generic features when processing and clustering them, Precfix is generally applicable to all company projects written in different languages, handling different business logic, and deployed on different platforms. Finally, Precfix consists of an offline patch discovery phase and an online patch recommendation phase. The online phase is designed to be extremely responsive and can finish recommending patches within milliseconds in practice. We found that being scalable and efficient is extremely important for patch recommendation tools to be integrated into day-to-day interactive and repetitive development tasks, such as code reviewing.

ä¸Šè¿°ä»£ç åº“å’Œå¼€å‘ç¯å¢ƒçš„ç‰¹ç‚¹ä½¿å¾—é‡‡ç”¨ç°æœ‰æŠ€æœ¯å˜å¾—ä¸åˆé€‚ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§å®ç”¨çš„è¡¥ä¸æ¨èæ–¹æ³•Precfixï¼Œå½“åº”ç”¨äºå¤§è§„æ¨¡çš„å·¥ä¸šä»£ç åº“æ—¶ï¼Œåœ¨ç²¾åº¦å’Œæ•ˆç‡æ–¹é¢è¿›è¡Œäº†å®šåˆ¶æ”¹è¿›ã€‚é¦–å…ˆï¼ŒPrecfixä¸ä¾èµ–äºæ ‡è®°çš„ç¼ºé™·æˆ–è¡¥ä¸ï¼Œè¿™äº›åœ¨å®è·µä¸­å¾ˆéš¾è·å¾—ã€‚ç›¸åï¼Œæˆ‘ä»¬ä¼šè‡ªåŠ¨åœ°ä»å†å²å˜æ›´ä¸­æŒ–æ˜å‡ºå¤§é‡çš„ç¼ºé™·-è¡¥ä¸å¯¹ã€‚ä¸ºäº†æé«˜æŒ–æ˜ç»“æœçš„å‡†ç¡®æ€§ï¼Œæˆ‘ä»¬å¼•å…¥äº†ä¸€äº›ä¼˜åŒ–ï¼Œè¿™äº›ä¼˜åŒ–è€ƒè™‘äº†æäº¤bugä¿®å¤æ›´æ”¹æ—¶å…¸å‹å¼€å‘äººå‘˜è¡Œä¸ºçš„ç‰¹å¾ã€‚æˆ‘ä»¬è¿˜å…è®¸å¼€å‘äººå‘˜åœ¨å¾ªç¯ä¸­å¯¹æ¨èçš„è¡¥ä¸çš„è´¨é‡æä¾›åé¦ˆï¼Œè¿™äº›åé¦ˆç”¨äºæé«˜å°†æ¥æ¨èçš„ç²¾åº¦ã€‚å…¶æ¬¡ï¼Œç”±äºç¼ºé™·å’Œè¡¥ä¸æ˜¯ä»æ•´ä¸ªå…¬å¸çš„ä»£ç åº“ä¸­æŒ–æ˜å‡ºæ¥çš„ï¼Œå¹¶ä¸”æˆ‘ä»¬åœ¨å¤„ç†å’Œé›†ç¾¤å®ƒä»¬æ—¶ä½¿ç”¨é€šç”¨ç‰¹æ€§ï¼Œæ‰€ä»¥Precfixé€šå¸¸é€‚ç”¨äºç”¨ä¸åŒè¯­è¨€ç¼–å†™çš„æ‰€æœ‰å…¬å¸é¡¹ç›®ï¼Œå¤„ç†ä¸åŒçš„ä¸šåŠ¡é€»è¾‘ï¼Œå¹¶éƒ¨ç½²åœ¨ä¸åŒçš„å¹³å°ä¸Šã€‚æœ€åï¼ŒPrecfixåŒ…æ‹¬ä¸€ä¸ªç¦»çº¿è¡¥ä¸å‘ç°é˜¶æ®µå’Œä¸€ä¸ªåœ¨çº¿è¡¥ä¸æ¨èé˜¶æ®µã€‚åœ¨çº¿é˜¶æ®µçš„è®¾è®¡æ˜¯éå¸¸æ•æ„Ÿçš„ï¼Œåœ¨å®è·µä¸­å¯ä»¥åœ¨å‡ æ¯«ç§’å†…å®Œæˆæ¨èè¡¥ä¸ã€‚æˆ‘ä»¬å‘ç°ï¼Œå¯¹äºå°†è¡¥ä¸æ¨èå·¥å…·é›†æˆåˆ°æ—¥å¸¸äº¤äº’å’Œé‡å¤çš„å¼€å‘ä»»åŠ¡(å¦‚ä»£ç å®¡æŸ¥)æ¥è¯´ï¼Œå¯ä¼¸ç¼©æ€§å’Œæ•ˆç‡æ˜¯éå¸¸é‡è¦çš„ã€‚

Precfix has been implemented and deployed as an internal web service in Alibaba. It is also integrated as a part of the code review process and provides patch recommendations whenever developers commit new changes to the codebase. We evaluated the effectiveness and efficiency of Precfix, and demonstrate its usefulness on a large-scale industrial benchmark with over 10,000 projects, spanning over more than 15 million commits and 30 million files.

Precfixå·²ç»åœ¨é˜¿é‡Œå·´å·´å†…éƒ¨å®ç°å¹¶éƒ¨ç½²ä¸ºä¸€é¡¹å†…éƒ¨webæœåŠ¡ã€‚å®ƒè¿˜é›†æˆä¸ºä»£ç å®¡æŸ¥è¿‡ç¨‹çš„ä¸€éƒ¨åˆ†ï¼Œå¹¶åœ¨å¼€å‘äººå‘˜æäº¤å¯¹ä»£ç åº“çš„æ–°æ›´æ”¹æ—¶æä¾›è¡¥ä¸å»ºè®®ã€‚æˆ‘ä»¬è¯„ä¼°äº†Precfixçš„æœ‰æ•ˆæ€§å’Œæ•ˆç‡ï¼Œå¹¶åœ¨è¶…è¿‡10,000ä¸ªé¡¹ç›®çš„å¤§å‹å·¥ä¸šåŸºå‡†æµ‹è¯•ä¸­å±•ç¤ºäº†å®ƒçš„æœ‰æ•ˆæ€§ï¼Œè¿™äº›é¡¹ç›®æ¶‰åŠè¶…è¿‡1,500ä¸‡æ¬¡æäº¤å’Œ3,000ä¸‡ä¸ªæ–‡ä»¶ã€‚

Contributions.We make the following contributions in this paper. 
- We propose Precfixâ€” a semi-automated patch recommendation tool for large scale industrial codebase. 
- Precfix implements customized optimizations in defect-patch pair mining and clustering, which help improve the accuracy of patch recommendation over existing techniques. 
- Precfix managed to extract 3K defect templates from 10K projects. Our approach is able to make recommendations within milliseconds and achieves a false positive rate of 22% confirmed by manual review. 
- We conducted a small-scale user study and the majority (10/12) of the interviewed developers appreciated Precfix, which has been rolled out to Alibaba to support various critical businesses.

è´¡çŒ®ã€‚æˆ‘ä»¬åœ¨æœ¬æ–‡ä¸­åšå‡ºäº†ä»¥ä¸‹è´¡çŒ®ã€‚

- æˆ‘ä»¬å»ºè®®Precfix -ä¸€ä¸ªåŠè‡ªåŠ¨çš„è¡¥ä¸æ¨èå·¥å…·ï¼Œä¸ºå¤§è§„æ¨¡çš„å·¥ä¸šä»£ç åº“ã€‚
- Precfixåœ¨ç¼ºé™·-è¡¥ä¸å¯¹æŒ–æ˜å’Œèšç±»ä¸­å®ç°äº†è‡ªå®šä¹‰ä¼˜åŒ–ï¼Œè¿™æœ‰åŠ©äºæé«˜ä¸ç°æœ‰æŠ€æœ¯ç›¸æ¯”çš„è¡¥ä¸æ¨èçš„å‡†ç¡®æ€§ã€‚
- Precfixè®¾æ³•ä»10Ké¡¹ç›®ä¸­æå–3Kä¸ªç¼ºé™·æ¨¡æ¿ã€‚æˆ‘ä»¬çš„æ–¹æ³•èƒ½å¤Ÿåœ¨å‡ æ¯«ç§’å†…ç»™å‡ºå»ºè®®ï¼Œå¹¶é€šè¿‡äººå·¥æ£€æŸ¥è·å¾—22%çš„è¯¯é˜³æ€§ç‡ã€‚
- æˆ‘ä»¬è¿›è¡Œäº†ä¸€é¡¹å°è§„æ¨¡çš„ç”¨æˆ·ç ”ç©¶ï¼Œå¤§å¤šæ•°(10/12)å—è®¿å¼€å‘è€…å¯¹Precfixè¡¨ç¤ºèµèµã€‚Precfixå·²ç»åœ¨é˜¿é‡Œå·´å·´æ¨å‡ºï¼Œä»¥æ”¯æŒå„ç§å…³é”®ä¸šåŠ¡ã€‚

## 2 RELATEDWORK

The techniques presented in this paper intersect with different areas of research. In this section, we compare Precfix with fault localization, automated patch generation, and patch recommendation.

æœ¬æ–‡ä»‹ç»çš„æŠ€æœ¯ä¸ä¸åŒçš„ç ”ç©¶é¢†åŸŸç›¸äº¤å‰ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†Precfixä¸æ•…éšœå®šä½ã€è‡ªåŠ¨è¡¥ä¸ç”Ÿæˆå’Œè¡¥ä¸æ¨èè¿›è¡Œæ¯”è¾ƒã€‚

### 2.1 Fault Localization

Fault localization [41, 51, 54, 60] is the activity of identifying the locations of faults in a program. Many different types of fault localization techniques have been proposed. Spectrum-based fault localization [1, 18] utilizes test coverage information to pinpoint faulty program or statistical techniques. For example, Tarantula [18] uses a homonym ranking metric to calculate the suspiciousness values of statements, which are calculated according to the frequency of the statements in passing and failing test cases. Mutation-based fault localization [35, 40] mutates a program and runs its test cases, using the test results to locate faults. For example, Metallaxis [40] generates a set of mutants for each statement, assigns each mutant a suspiciousness score, and aggregates the scores to yield the suspiciousness of the statement. Other faults localization techniques identify locations of faults in some alternative ways, including dynamic program dependency analysis [2, 45], stack trace analysis [53, 55], conditional expressions mutation analysis [58], information retrieval [59], and version history analysis [23, 44].

[
[41] Spencer Pearson, Jose Campos, Rene Just, Gordon Fraser, Rui Abreu, Michael D. Ernst, Deric Pang, and Benjamin Keller. 2017. Evaluating and Improving Fault Localization. In International Conference on Software Engineering. 609â€“620. 
[51] Shaowei Wang, David Lo, Lingxiao Jiang, Lucia, and Hoong Chuin Lau. 2011. Search-Based Fault Localization. In International Conference on Automated Software Engineering. 556â€“559.
[54] W. Eric Wong, Ruizhi Gao, Yihao Li, Rui Abreu, and Franz Wotawa. 2016. A Survey on Software Fault Localization. Transactions on Software Engineering 42, 8 (2016), 707â€“740.
[60] Daming Zou, Jingjing Liang, Yingfei Xiong, Michael D Ernst, and Lu Zhang. 2019. An Empirical Study of Fault Localization Families and Their Combinations. Transactions on Software Engineering (2019), To appear.
1
18
35
40
2
45
53
55
58
59
23
44
]

æ•…éšœå®šä½[41,51,54,60]æ˜¯è¯†åˆ«ç¨‹åºä¸­æ•…éšœä½ç½®çš„æ´»åŠ¨ã€‚äººä»¬æå‡ºäº†è®¸å¤šä¸åŒç±»å‹çš„æ•…éšœå®šä½æŠ€æœ¯ã€‚åŸºäºé¢‘è°±çš„æ•…éšœå®šä½[1,18]åˆ©ç”¨æµ‹è¯•è¦†ç›–ä¿¡æ¯æ¥æŸ¥æ˜æ•…éšœç¨‹åºæˆ–ç»Ÿè®¡æŠ€æœ¯ã€‚ä¾‹å¦‚ï¼ŒTarantula[18]ä½¿ç”¨åŒæºæ€§æ’ååº¦é‡æ¥è®¡ç®—è¯­å¥çš„å¯ç–‘å€¼ï¼Œè¿™äº›å¯ç–‘å€¼æ˜¯æ ¹æ®é€šè¿‡å’Œå¤±è´¥æµ‹è¯•ç”¨ä¾‹ä¸­è¯­å¥çš„é¢‘ç‡æ¥è®¡ç®—çš„ã€‚åŸºäºçªå˜çš„æ•…éšœå®šä½[35,40]ä½¿ç¨‹åºå‘ç”Ÿçªå˜å¹¶è¿è¡Œå…¶æµ‹è¯•ç”¨ä¾‹ï¼Œä½¿ç”¨æµ‹è¯•ç»“æœå®šä½æ•…éšœã€‚ä¾‹å¦‚ï¼ŒMetallaxis[40]ä¸ºæ¯ä¸ªè¯­å¥ç”Ÿæˆä¸€ç»„çªå˜ä½“ï¼Œä¸ºæ¯ä¸ªçªå˜ä½“åˆ†é…ä¸€ä¸ªå¯ç–‘æ€§åˆ†æ•°ï¼Œå¹¶èšåˆè¿™äº›åˆ†æ•°ä»¥ç”Ÿæˆè¯­å¥çš„å¯ç–‘æ€§ã€‚å…¶ä»–çš„æ•…éšœå®šä½æŠ€æœ¯é€šè¿‡ä¸€äº›å¯é€‰çš„æ–¹æ³•æ¥è¯†åˆ«æ•…éšœçš„ä½ç½®ï¼ŒåŒ…æ‹¬åŠ¨æ€ç¨‹åºä¾èµ–åˆ†æ[2,45]ã€å †æ ˆè·Ÿè¸ªåˆ†æ[53,55]ã€æ¡ä»¶è¡¨è¾¾å¼çªå˜åˆ†æ[58]ã€ä¿¡æ¯æ£€ç´¢[59]å’Œç‰ˆæœ¬å†å²åˆ†æ[23,44]ã€‚

### 2.2 Automated Patch Generation

Automated patch generation [11, 34, 50, 57] aims to automatically repair software systems by producing a fix that can be validated before it is fully accepted into the system. Automated patch generation techniques can be divided into two main categories: generate-andvalidate approaches and semantics-driven approaches. Generateand- validate approaches [7, 22, 32, 43, 52] iteratively execute two activities: patch generation, which produces candidate patch of the bug by making atomic changes or applying bug fix templates; patch validation, which checks the correctness of the generated solutions by running test cases. For example, GenProg [52] uses genetic programming to guide the generation and validation activities. At every iteration, it randomly determines the location to apply an atomic change, according to a probability distribution that matches the suspiciousness of the statements computed with fault localization algorithms. Every candidate solution is validated running the available test suite. It defines a fitness function that measures the fitness of each program variant based on the number of passing and failing test cases. Semantics-driven approaches [21, 30, 38] formally encode the problem, either as a formula whose solutions correspond to the possible fixes, or as an analytical procedure whose outcome is a fix. A solution found by such approaches is correct by construction, thus no validation is needed. For example, SemFix [38] uses fault localization to identify the statement that should be changed, then tries to synthesize a fix by modifying a branch predicate or changing the right hand side of an assignment.

è‡ªåŠ¨è¡¥ä¸ç”Ÿæˆ[11,34,50,57]çš„ç›®çš„æ˜¯é€šè¿‡ç”Ÿæˆä¸€ä¸ªè¡¥ä¸æ¥è‡ªåŠ¨ä¿®å¤è½¯ä»¶ç³»ç»Ÿï¼Œè¿™ä¸ªè¡¥ä¸å¯ä»¥åœ¨ç³»ç»Ÿå®Œå…¨æ¥å—ä¹‹å‰è¿›è¡ŒéªŒè¯ã€‚è‡ªåŠ¨è¡¥ä¸ç”ŸæˆæŠ€æœ¯å¯ä»¥åˆ†ä¸ºä¸¤å¤§ç±»:ç”Ÿæˆå’ŒéªŒè¯æ–¹æ³•å’Œè¯­ä¹‰é©±åŠ¨æ–¹æ³•ã€‚Generateand- validateæ–¹æ³•[7,22,32,43,52]è¿­ä»£åœ°æ‰§è¡Œä¸¤ä¸ªæ´»åŠ¨:è¡¥ä¸ç”Ÿæˆï¼Œé€šè¿‡è¿›è¡ŒåŸå­æ€§æ›´æ”¹æˆ–åº”ç”¨bugä¿®å¤æ¨¡æ¿ç”Ÿæˆbugçš„å€™é€‰è¡¥ä¸;è¡¥ä¸éªŒè¯ï¼Œå®ƒé€šè¿‡è¿è¡Œæµ‹è¯•ç”¨ä¾‹æ¥æ£€æŸ¥ç”Ÿæˆçš„è§£å†³æ–¹æ¡ˆçš„æ­£ç¡®æ€§ã€‚ä¾‹å¦‚ï¼ŒGenProg[52]ä½¿ç”¨é—ä¼ ç¼–ç¨‹æ¥æŒ‡å¯¼ç”Ÿæˆå’ŒéªŒè¯æ´»åŠ¨ã€‚åœ¨æ¯ä¸€æ¬¡è¿­ä»£ä¸­ï¼Œå®ƒæ ¹æ®ä¸æ•…éšœå®šä½ç®—æ³•è®¡ç®—çš„è¯­å¥å¯ç–‘æ€§ç›¸åŒ¹é…çš„æ¦‚ç‡åˆ†å¸ƒï¼Œéšæœºç¡®å®šåº”ç”¨åŸå­æ›´æ”¹çš„ä½ç½®ã€‚è¿è¡Œå¯ç”¨çš„æµ‹è¯•å¥—ä»¶å¯¹æ¯ä¸ªå€™é€‰è§£å†³æ–¹æ¡ˆè¿›è¡ŒéªŒè¯ã€‚å®ƒå®šä¹‰äº†ä¸€ä¸ªé€‚åº”åº¦å‡½æ•°ï¼Œè¯¥å‡½æ•°æ ¹æ®é€šè¿‡å’Œå¤±è´¥æµ‹è¯•ç”¨ä¾‹çš„æ•°é‡æ¥åº¦é‡æ¯ä¸ªç¨‹åºå˜ä½“çš„é€‚åº”åº¦ã€‚è¯­ä¹‰é©±åŠ¨çš„æ–¹æ³•[21,30,38]å°†é—®é¢˜æ­£å¼ç¼–ç ä¸ºä¸€ä¸ªå…¬å¼ï¼Œå…¶è§£å†³æ–¹æ¡ˆå¯¹åº”äºå¯èƒ½çš„ä¿®å¤ï¼Œæˆ–è€…ä½œä¸ºä¸€ä¸ªåˆ†æè¿‡ç¨‹ï¼Œå…¶ç»“æœæ˜¯ä¿®å¤ã€‚è¿™ç§æ–¹æ³•æ‰¾åˆ°çš„è§£å†³æ–¹æ¡ˆé€šè¿‡æ„é€ æ˜¯æ­£ç¡®çš„ï¼Œå› æ­¤ä¸éœ€è¦éªŒè¯ã€‚ä¾‹å¦‚ï¼ŒSemFix[38]ä½¿ç”¨é”™è¯¯å®šä½æ¥è¯†åˆ«åº”è¯¥æ›´æ”¹çš„è¯­å¥ï¼Œç„¶åå°è¯•é€šè¿‡ä¿®æ”¹åˆ†æ”¯è°“è¯æˆ–æ›´æ”¹èµ‹å€¼çš„å³ä¾§æ¥ç»¼åˆä¿®å¤ã€‚

### 2.3 Patch Recommendation

Patch recommendation [3, 16, 20, 24, 36] suggests a few candidate changes which may repair a given fault. In some cases, the recommended patches are perfect fixes, while in other cases some efforts are required from the developers to produce the final fix. Although these techniques do not guarantee a working repair, their results are still useful in assisting developers in deriving the patch. A number of patch recommendation techniques have been proposed so far. For example, Getafix [3] from Facebook learns recurring fix patterns for static analysis warnings and suggests fixes for future occurrences of the same bug category. It firstly splits a given set of example fixes into AST-level edits, then it learns recurring fix patterns from these edits based on a clustering technique which produces a hierarchy of fix patterns. Finally, given a bug under fix, it finds suitable fix patterns, ranks candidate fixes, and suggests the top-most fixes to developers. As another example, CLEVER [36] from Ubisoft aims to intercept risky commits before they reach the central repository. It first builds a metric-based model to assess the risky level of incoming commits, then it uses clone detection to compare code blocks in risky commits with some known historical fault-introducing commits.

è¡¥ä¸å»ºè®®[3,16,20,24,36]å»ºè®®ä¸€äº›å¯èƒ½ä¿®å¤ç»™å®šé”™è¯¯çš„å€™é€‰æ›´æ”¹ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ¨èçš„è¡¥ä¸æ˜¯å®Œç¾çš„ä¿®å¤ï¼Œè€Œåœ¨å…¶ä»–æƒ…å†µä¸‹ï¼Œåˆ™éœ€è¦å¼€å‘äººå‘˜è¿›è¡Œä¸€äº›å·¥ä½œæ¥ç”Ÿæˆæœ€ç»ˆçš„ä¿®å¤ã€‚è™½ç„¶è¿™äº›æŠ€æœ¯ä¸èƒ½ä¿è¯ä¿®å¤å·¥ä½œæ­£å¸¸è¿›è¡Œï¼Œä½†æ˜¯å®ƒä»¬çš„ç»“æœå¯¹äºå¸®åŠ©å¼€å‘äººå‘˜è·å¾—è¡¥ä¸è¿˜æ˜¯å¾ˆæœ‰ç”¨çš„ã€‚ç›®å‰å·²ç»æå‡ºäº†è®¸å¤šè¡¥ä¸æ¨èæŠ€æœ¯ã€‚ä¾‹å¦‚ï¼Œæ¥è‡ªFacebookçš„Getafix[3]å­¦ä¹ äº†é’ˆå¯¹é™æ€åˆ†æè­¦å‘Šçš„é‡å¤ä¿®å¤æ¨¡å¼ï¼Œå¹¶ä¸ºå°†æ¥å‡ºç°çš„ç›¸åŒbugç±»åˆ«æä¾›ä¿®å¤å»ºè®®ã€‚å®ƒé¦–å…ˆå°†ç»™å®šçš„ä¸€ç»„ç¤ºä¾‹ä¿®å¤åˆ’åˆ†ä¸ºæœ€å°å±‚æ¬¡çš„ç¼–è¾‘ï¼Œç„¶åæ ¹æ®ç”Ÿæˆä¿®å¤æ¨¡å¼å±‚æ¬¡ç»“æ„çš„é›†ç¾¤æŠ€æœ¯ä»è¿™äº›ç¼–è¾‘ä¸­å­¦ä¹ é‡å¤çš„ä¿®å¤æ¨¡å¼ã€‚æœ€åï¼Œå¯¹äºfixä¸‹çš„bugï¼Œå®ƒä¼šæ‰¾åˆ°åˆé€‚çš„ä¿®å¤æ¨¡å¼ï¼Œå¯¹å€™é€‰ä¿®å¤è¿›è¡Œæ’åºï¼Œå¹¶å‘å¼€å‘äººå‘˜å»ºè®®æœ€é‡è¦çš„ä¿®å¤ã€‚å¦ä¸€ä¸ªä¾‹å­æ˜¯ï¼ŒUbisoftçš„èªæ˜çš„[36]æ—¨åœ¨åœ¨å±é™©çš„æäº¤åˆ°è¾¾ä¸­å¤®å­˜å‚¨åº“ä¹‹å‰æ‹¦æˆªå®ƒä»¬ã€‚å®ƒé¦–å…ˆæ„å»ºä¸€ä¸ªåŸºäºåº¦é‡çš„æ¨¡å‹æ¥è¯„ä¼°ä¼ å…¥æäº¤çš„é£é™©çº§åˆ«ï¼Œç„¶åä½¿ç”¨å…‹éš†æ£€æµ‹æ¥æ¯”è¾ƒé£é™©æäº¤ä¸­çš„ä»£ç å—ä¸ä¸€äº›å·²çŸ¥çš„å†å²é”™è¯¯å¼•å…¥æäº¤ã€‚

All these aforementioned techniques depend on existing patches or already-known bug patterns. In contrast, we do not assume enough debugging reports, and we extract templates of defectpatch pairs through data mining. Open-source dataset such as Defect4J [19] contains labeled defects and the corresponding patches, which have been examined and analyzed by many researchers. Yet, recent studies [56] indicate that many state-of-the-art patch generation techniques has the problem of over-fitting to specific benchmark set. Therefore, many of the existing techniques cannot be directly applied on the industrial codebase, which is quite different from the open-source dataset in many ways.

æ‰€æœ‰è¿™äº›å‰é¢æåˆ°çš„æŠ€æœ¯éƒ½ä¾èµ–äºç°æœ‰çš„è¡¥ä¸æˆ–å·²ç»çŸ¥é“çš„bugæ¨¡å¼ã€‚ç›¸åï¼Œæˆ‘ä»¬æ²¡æœ‰å‡è®¾è¶³å¤Ÿçš„è°ƒè¯•æŠ¥å‘Šï¼Œè€Œæ˜¯é€šè¿‡æ•°æ®æŒ–æ˜æå–ç¼ºé™·è¡¥ä¸å¯¹çš„æ¨¡æ¿ã€‚åƒdefectè¿™æ ·çš„å¼€æºæ•°æ®é›†åŒ…å«äº†æ ‡è®°çš„defectå’Œç›¸åº”çš„patchï¼Œè¿™äº›éƒ½æ˜¯å¾ˆå¤šç ”ç©¶è€…ç ”ç©¶å’Œåˆ†æè¿‡çš„ã€‚ç„¶è€Œï¼Œæœ€è¿‘çš„ç ”ç©¶[56]è¡¨æ˜ï¼Œè®¸å¤šæœ€å…ˆè¿›çš„è¡¥ä¸ç”ŸæˆæŠ€æœ¯éƒ½å­˜åœ¨å¯¹ç‰¹å®šåŸºå‡†é›†è¿‡åº¦æ‹Ÿåˆçš„é—®é¢˜ã€‚å› æ­¤ï¼Œè®¸å¤šç°æœ‰çš„æŠ€æœ¯ä¸èƒ½ç›´æ¥åº”ç”¨äºå·¥ä¸šä»£ç åº“ï¼Œè¿™åœ¨è®¸å¤šæ–¹é¢ä¸å¼€æºæ•°æ®é›†æœ‰å¾ˆå¤§çš„ä¸åŒã€‚

## 3 PRELIMINARY STUDY

To better understand the codebase at Alibaba and the challenges in applying existing techniques in the industrial development environment, we conducted a preliminary study of the usage scenarios of patch recommendation techniques within the company and empirically analyzed the characteristics of the company codebase.

ä¸ºäº†æ›´å¥½åœ°äº†è§£é˜¿é‡Œå·´å·´çš„ä»£ç åº“ä»¥åŠåœ¨è¡Œä¸šå‘å±•ç¯å¢ƒä¸­åº”ç”¨ç°æœ‰æŠ€æœ¯æ‰€é¢ä¸´çš„æŒ‘æˆ˜ï¼Œæˆ‘ä»¬å¯¹å…¬å¸å†…éƒ¨è¡¥ä¸æ¨èæŠ€æœ¯çš„ä½¿ç”¨åœºæ™¯è¿›è¡Œäº†åˆæ­¥ç ”ç©¶ï¼Œå¹¶å¯¹å…¬å¸ä»£ç åº“çš„ç‰¹ç‚¹è¿›è¡Œäº†å®è¯åˆ†æã€‚

### 3.1 Challenges for Existing Techniques

Through manual inspection, interviews with developers, and empirical studies, we identified three key challenges for existing fault localization and automated patch generation techniques to be successfully applied on our benchmark.

é€šè¿‡äººå·¥æ£€æŸ¥ã€ä¸å¼€å‘äººå‘˜çš„è®¿è°ˆå’Œå®è¯ç ”ç©¶ï¼Œæˆ‘ä»¬ç¡®å®šäº†ç°æœ‰æ•…éšœå®šä½å’Œè‡ªåŠ¨ç”Ÿæˆè¡¥ä¸æŠ€æœ¯åœ¨æˆ‘ä»¬çš„åŸºå‡†ä¸ŠæˆåŠŸåº”ç”¨çš„ä¸‰ä¸ªå…³é”®æŒ‘æˆ˜ã€‚

- Insufficient Labeled Data. 
A lot of fault localization and automated patch generation techniques require labeled defect and patch samples to be able to extract patterns of typical bug fixes. Yet, this is a substantial obstacle in our case, since there exists very few labeled defects or patches in the company codebase. Moreover, due to the widespread legacy code in the codebase, a large number of software projects only have partial debugging reports and very limited test cases. The commit messages may be succinct and do not follow any standard template either. Therefore, it is challenging to label defects and the associated fixes manually, given the size and complexity of the codebase. The business logic and bug fix patterns of the internal company codebase are quite different from that of open source projects [42, 47]. Thus, we decide not to directly use the labeled data from open-source projects.

è®¸å¤šé”™è¯¯å®šä½å’Œè‡ªåŠ¨è¡¥ä¸ç”ŸæˆæŠ€æœ¯éƒ½éœ€è¦æ ‡è®°çš„ç¼ºé™·å’Œè¡¥ä¸æ ·æœ¬æ¥æå–å…¸å‹é”™è¯¯ä¿®å¤çš„æ¨¡å¼ã€‚ç„¶è€Œï¼Œåœ¨æˆ‘ä»¬çš„æ¡ˆä¾‹ä¸­ï¼Œè¿™æ˜¯ä¸€ä¸ªå®è´¨æ€§çš„éšœç¢ï¼Œå› ä¸ºåœ¨å…¬å¸çš„ä»£ç åº“ä¸­å­˜åœ¨å¾ˆå°‘æ ‡è®°çš„ç¼ºé™·æˆ–è¡¥ä¸ã€‚æ­¤å¤–ï¼Œç”±äºä»£ç åº“ä¸­å¹¿æ³›å­˜åœ¨é—ç•™ä»£ç ï¼Œå¤§é‡è½¯ä»¶é¡¹ç›®åªæœ‰éƒ¨åˆ†è°ƒè¯•æŠ¥å‘Šå’Œéå¸¸æœ‰é™çš„æµ‹è¯•ç”¨ä¾‹ã€‚æäº¤æ¶ˆæ¯å¯èƒ½å¾ˆç®€æ´ï¼Œä¹Ÿä¸éµå¾ªä»»ä½•æ ‡å‡†æ¨¡æ¿ã€‚å› æ­¤ï¼Œè€ƒè™‘åˆ°ä»£ç åº“çš„å¤§å°å’Œå¤æ‚æ€§ï¼Œæ‰‹å·¥æ ‡è®°ç¼ºé™·å’Œç›¸å…³çš„ä¿®å¤æ˜¯å¾ˆæœ‰æŒ‘æˆ˜æ€§çš„ã€‚å†…éƒ¨å…¬å¸ä»£ç åº“çš„ä¸šåŠ¡é€»è¾‘å’Œbugä¿®å¤æ¨¡å¼ä¸å¼€æºé¡¹ç›®çš„æ¨¡å¼æœ‰å¾ˆå¤§çš„ä¸åŒ[42,47]ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å†³å®šä¸ç›´æ¥ä½¿ç”¨æ¥è‡ªå¼€æºé¡¹ç›®çš„æ ‡è®°æ•°æ®ã€‚

- High Responsive Standard. 
The application scenario of patch recommendation in Alibaba is highly interactive. Patch recommendation needs to be run whenever new commits are submitted by developers for code review. The recommended patches are then checked by developers, who may decide to incorporate the suggestions into the commits. On average, a developer submits three to four commits per week, and both the submitter and reviewer expect prompt patch recommendations to avoid delays during the review process. Therefore, the responding time for patch recommendation is supposed to be reasonably low in order to be integrated into the development routine. This renders some automated patch generation approaches inappropriate, since they need to repeatedly compile and execute tests for each identified defect.

é˜¿é‡Œå·´å·´çš„è¡¥ä¸æ¨èåº”ç”¨åœºæ™¯äº¤äº’æ€§å¼ºã€‚æ¯å½“å¼€å‘äººå‘˜æäº¤æ–°çš„æäº¤ä»¥è¿›è¡Œä»£ç å®¡æŸ¥æ—¶ï¼Œéƒ½éœ€è¦è¿è¡Œè¡¥ä¸æ¨èã€‚ç„¶åç”±å¼€å‘äººå‘˜æ£€æŸ¥æ¨èçš„è¡¥ä¸ï¼Œä»–ä»¬å¯èƒ½å†³å®šå°†å»ºè®®åˆå¹¶åˆ°æäº¤ä¸­ã€‚å¹³å‡è€Œè¨€ï¼Œå¼€å‘äººå‘˜æ¯å‘¨æäº¤ä¸‰åˆ°å››æ¬¡æäº¤ï¼Œæäº¤è€…å’Œå®¡æŸ¥è€…éƒ½å¸Œæœ›å¾—åˆ°åŠæ—¶çš„è¡¥ä¸å»ºè®®ï¼Œä»¥é¿å…å®¡æŸ¥è¿‡ç¨‹ä¸­çš„å»¶è¿Ÿã€‚å› æ­¤ï¼Œä¸ºäº†é›†æˆåˆ°å¼€å‘ä¾‹ç¨‹ä¸­ï¼Œè¡¥ä¸æ¨èçš„å“åº”æ—¶é—´åº”è¯¥æ¯”è¾ƒä½ã€‚è¿™ä½¿å¾—ä¸€äº›è‡ªåŠ¨ç”Ÿæˆè¡¥ä¸çš„æ–¹æ³•å˜å¾—ä¸åˆé€‚ï¼Œå› ä¸ºå®ƒä»¬éœ€è¦é‡å¤åœ°ç¼–è¯‘å’Œæ‰§è¡Œæ¯ä¸ªå·²è¯†åˆ«ç¼ºé™·çš„æµ‹è¯•ã€‚

- Generalizability Requirement. 
Our benchmark set consists of more than 10K projects supporting more than 100 software applications. These applications cover a variety of domains including e-commerce, finance, cloud computing, and artificial intelligence, many of which are used by millions of users on a daily basis. The patch recommendation techniques should be generalizable to cover all different projects and defect types.

æˆ‘ä»¬çš„åŸºå‡†æµ‹è¯•é›†åŒ…å«æ”¯æŒ100å¤šä¸ªè½¯ä»¶åº”ç”¨ç¨‹åºçš„10Kå¤šä¸ªé¡¹ç›®ã€‚è¿™äº›åº”ç”¨ç¨‹åºæ¶µç›–äº†ç”µå­å•†åŠ¡ã€é‡‘èã€äº‘è®¡ç®—å’Œäººå·¥æ™ºèƒ½ç­‰å¤šä¸ªé¢†åŸŸï¼Œå…¶ä¸­è®¸å¤šåº”ç”¨ç¨‹åºæ¯å¤©éƒ½æœ‰æ•°ç™¾ä¸‡ç”¨æˆ·ä½¿ç”¨ã€‚è¡¥ä¸æ¨èæŠ€æœ¯åº”è¯¥æ˜¯é€šç”¨çš„ï¼Œä»¥è¦†ç›–æ‰€æœ‰ä¸åŒçš„é¡¹ç›®å’Œç¼ºé™·ç±»å‹ã€‚

### 3.2 Challenges in Defect-Patch Identification

There exists techniques [27â€“29, 48] which automatically identify changes of certain kinds, e.g., bugs and fixes, from commit histories. These techniques, such as the SZZ algorithm [48], can be useful for labeling defect-patch pairs in the absence of high-quality labeled data. The high-level idea is to first locate bug-fixing commits based on keywords in commit messages and debugging reports. For example, a commit is considered as bug-fixing commit if it appears in a bug report or its commit message contains keywords such as â€œbugâ€ and â€œfixâ€. For each identified bug-fixing commit, one can trace each line of changed code back in history to locate the bug-inducing commits using version control information such as git-blame [12].

æœ‰ä¸€äº›æŠ€æœ¯[27 - 29,48]å¯ä»¥è‡ªåŠ¨åœ°ä»æäº¤å†å²ä¸­è¯†åˆ«æŸäº›ç±»å‹çš„å˜æ›´ï¼Œä¾‹å¦‚ï¼Œbugå’Œä¿®å¤ã€‚è¿™äº›æŠ€æœ¯ï¼Œä¾‹å¦‚SZZç®—æ³•[48]ï¼Œå¯ä»¥åœ¨ç¼ºå°‘é«˜è´¨é‡æ ‡è®°æ•°æ®çš„æƒ…å†µä¸‹ç”¨äºæ ‡è®°ç¼ºé™·-è¡¥ä¸å¯¹ã€‚é«˜çº§æ€æƒ³æ˜¯é¦–å…ˆæ ¹æ®æäº¤æ¶ˆæ¯å’Œè°ƒè¯•æŠ¥å‘Šä¸­çš„å…³é”®å­—å®šä½ä¿®å¤é”™è¯¯çš„æäº¤ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæäº¤å‡ºç°åœ¨bugæŠ¥å‘Šä¸­ï¼Œæˆ–è€…å…¶æäº¤æ¶ˆæ¯åŒ…å«â€œbugâ€å’Œâ€œfixâ€ä¹‹ç±»çš„å…³é”®å­—ï¼Œåˆ™å°†å…¶è§†ä¸ºbugä¿®å¤æäº¤ã€‚å¯¹äºæ¯ä¸ªå·²ç¡®å®šçš„bugä¿®å¤æäº¤ï¼Œå¯ä»¥ä½¿ç”¨ç‰ˆæœ¬æ§åˆ¶ä¿¡æ¯(å¦‚git-blame[12])è·Ÿè¸ªå†å²ä¸Šæ›´æ”¹çš„æ¯è¡Œä»£ç ï¼Œä»¥å®šä½å¯¼è‡´bugçš„æäº¤ã€‚

Various optimizations have been introduced in the SZZ algorithm to reduce the false positives. For example, the timestamp of a candidate bug-inducing commit is compared with the time when the bug is reported to rule out unreasonable results. Yet, we found that even with these optimizations, the SZZ algorithm still does not perform well on our benchmark (25% true positive rate). To figure out the reason why the SZZ algorithm does not perform well on our codebase, we quantitatively analyzed the dataset and identified two stages in the algorithm where imprecision can be introduced: (1) the identification of bug-fixing commits, and (2) the location of bug-inducing commits via back-tracing in history.

SZZç®—æ³•ä¸­å¼•å…¥äº†å„ç§ä¼˜åŒ–ä»¥å‡å°‘è¯¯æŠ¥ã€‚ä¾‹å¦‚ï¼Œå°†å¼•å‘bugçš„å€™é€‰æäº¤çš„æ—¶é—´æˆ³ä¸æŠ¥å‘Šbugä»¥æ’é™¤ä¸åˆç†ç»“æœçš„æ—¶é—´è¿›è¡Œæ¯”è¾ƒã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å‘ç°å³ä½¿ä½¿ç”¨è¿™äº›ä¼˜åŒ–ï¼ŒSZZç®—æ³•åœ¨æˆ‘ä»¬çš„åŸºå‡†æµ‹è¯•(25%çš„çœŸå®é˜³æ€§ç‡)ä¸Šä»ç„¶è¡¨ç°ä¸ä½³ã€‚æ‰¾å‡ºä¸ºä»€ä¹ˆSZZç®—æ³•ä¸æ‰§è¡Œæˆ‘ä»¬çš„ä»£ç åº“,æˆ‘ä»¬å®šé‡åˆ†ææ•°æ®é›†å’Œç¡®è®¤ä¸¤ä¸ªé˜¶æ®µåœ¨ä¸ç²¾ç¡®çš„ç®—æ³•å¯ä»¥ä»‹ç»:(1)ç¡®å®šçš„bugä¿®å¤æäº¤,å’Œ(2)çš„ä½ç½®é€šè¿‡å†å²ä¸Šback-tracing bug-inducingæäº¤ã€‚

- Imprecision in Locating Bug-Fixing Commits. 
The first reason causing imprecision is that the keyword matching approach is not always reliable. For example, through manual inspection, we discovered that a commit with the commit message containing the keyword â€œfixâ€, does not change any program logic and only modifies the label of an Android UI button. Even if a commit does fix a bug, it can also make irrelevant changes to other parts of the code. Fig. 1 shows the distribution of the number of changed files in each commit matched by at least one keyword. The keywords we used include â€œfixâ€, â€œbugâ€, â€œrepairâ€, â€œwrongâ€, â€œfailâ€, â€œproblemâ€, and their corresponding Chinese translations. About 60% of the commits change more than one file, among which 40% touch over two files. Many such commits are multi-purpose, causing imprecision in locating bug-fixing commits.

é€ æˆä¸ç²¾ç¡®çš„ç¬¬ä¸€ä¸ªåŸå› æ˜¯å…³é”®å­—åŒ¹é…æ–¹æ³•å¹¶ä¸æ€»æ˜¯å¯é çš„ã€‚ä¾‹å¦‚ï¼Œé€šè¿‡æ‰‹åŠ¨æ£€æŸ¥ï¼Œæˆ‘ä»¬å‘ç°æäº¤æ¶ˆæ¯åŒ…å«å…³é”®å­—â€œfixâ€ï¼Œä¸æ”¹å˜ä»»ä½•ç¨‹åºé€»è¾‘ï¼Œåªä¿®æ”¹Android UIæŒ‰é’®çš„æ ‡ç­¾ã€‚å³ä½¿æäº¤ç¡®å®ä¿®å¤äº†é”™è¯¯ï¼Œå®ƒä¹Ÿå¯èƒ½å¯¹ä»£ç çš„å…¶ä»–éƒ¨åˆ†åšå‡ºæ— å…³çš„æ›´æ”¹ã€‚å›¾1æ˜¾ç¤ºäº†è‡³å°‘ä¸€ä¸ªå…³é”®å­—åŒ¹é…çš„æ¯æ¬¡æäº¤ä¸­çš„æ›´æ”¹æ–‡ä»¶æ•°é‡çš„åˆ†å¸ƒã€‚æˆ‘ä»¬ä½¿ç”¨çš„å…³é”®è¯åŒ…æ‹¬â€œfixâ€ã€â€œbugâ€ã€â€œrepairâ€ã€â€œwrongâ€ã€â€œfailâ€ã€â€œproblemâ€ï¼Œä»¥åŠå¯¹åº”çš„ä¸­æ–‡ç¿»è¯‘ã€‚å¤§çº¦60%çš„æäº¤æ›´æ”¹ä¸æ­¢ä¸€ä¸ªæ–‡ä»¶ï¼Œå…¶ä¸­40%æ¶‰åŠä¸¤ä¸ªæ–‡ä»¶ã€‚è®¸å¤šè¿™æ ·çš„æäº¤æ˜¯å¤šç”¨é€”çš„ï¼Œå¯¼è‡´å®šä½é”™è¯¯ä¿®å¤æäº¤çš„ä¸ç²¾ç¡®æ€§ã€‚

- Imprecision in Locating Bug-Inducing Commits. Additional imprecision can be introduced when there are multiple bug-inducing commits in the history. When back-tracing in history, it is possible to end up with more than one commits, each partially contributing to the defect. We randomly select four projects from the dataset. Fig. 2 plots the distribution of the number of bug-inducing commits identified by the SZZ algorithm for each bug-fixing commit. For example, for project ğ‘ƒ1, among all the defects, 78% are induced by one commit, 14% are induced by two commits, 4% are induced by three commits, and 3% are induced by more than three commits. We found that the commit-level back-tracing often introduces too much irrelevant changes for the similar reason discussed before.

å½“å†å²ä¸­æœ‰å¤šä¸ªå¼•å‘bugçš„æäº¤æ—¶ï¼Œå¯èƒ½ä¼šå¼•å…¥é¢å¤–çš„ä¸ç²¾ç¡®æ€§ã€‚å½“å›æº¯å†å²æ—¶ï¼Œå¯èƒ½ä¼šå‡ºç°å¤šä¸ªæäº¤ï¼Œæ¯ä¸ªæäº¤éƒ½ä¼šéƒ¨åˆ†åœ°å¯¼è‡´ç¼ºé™·ã€‚æˆ‘ä»¬ä»æ•°æ®é›†ä¸­éšæœºé€‰æ‹©å››ä¸ªé¡¹ç›®ã€‚å›¾2æç»˜äº†SZZç®—æ³•è¯†åˆ«çš„æ¯ä¸ªbugä¿®å¤æäº¤çš„bugè¯±å¯¼æäº¤æ•°çš„åˆ†å¸ƒã€‚ä¾‹å¦‚,å¯¹äºé¡¹ç›®ğ‘ƒ1,åœ¨æ‰€æœ‰çš„ç¼ºé™·,78%æ˜¯ç”±ä¸€ä¸ªæäº¤,14%æ˜¯ç”±ä¸¤ä¸ªæäº¤,4%æ˜¯ç”±ä¸‰ä¸ªæ‰¿è¯º,3%æ˜¯ç”±ä¸‰ä¸ªä»¥ä¸Šæäº¤ã€‚æˆ‘ä»¬å‘ç°ï¼ŒåŸºäºå‰é¢è®¨è®ºè¿‡çš„ç±»ä¼¼åŸå› ï¼Œå§”å‘˜ä¼šçº§åˆ«çš„å›æº¯ç»å¸¸å¼•å…¥å¤ªå¤šä¸ç›¸å…³çš„æ›´æ”¹ã€‚

## 4 OUR APPROACH

Fig. 3 overviews the workflow of Precfix. Precfix consists of an offline patch discovery component and an online patch recommendation component. The patch discovery component first extracts potential defect-patch pairs from commits in the version controlled history, clusters defect-patch pairs based on their similarity, and finally extracts generic patch templates to be stored in a database. The patch recommendation component recommends patch candidates to developers and collects their feedback. It removes patches rejected by developers, and includes manually crafted patch templates submitted by developers to improve the patch database.

å›¾3æ¦‚è¿°äº†Precfixçš„å·¥ä½œæµç¨‹ã€‚PrecfixåŒ…å«ä¸€ä¸ªç¦»çº¿è¡¥ä¸å‘ç°ç»„ä»¶å’Œä¸€ä¸ªåœ¨çº¿è¡¥ä¸æ¨èç»„ä»¶ã€‚patch discoveryç»„ä»¶é¦–å…ˆä»ç‰ˆæœ¬æ§åˆ¶å†å²è®°å½•ä¸­çš„æäº¤ä¸­æå–å‡ºæ½œåœ¨çš„ç¼ºé™·-è¡¥ä¸å¯¹ï¼Œç„¶åæ ¹æ®ç¼ºé™·-è¡¥ä¸å¯¹ä¹‹é—´çš„ç›¸ä¼¼æ€§è¿›è¡Œèšç±»ï¼Œæœ€åæå–å‡ºè¦å­˜å‚¨åœ¨æ•°æ®åº“ä¸­çš„é€šç”¨è¡¥ä¸æ¨¡æ¿ã€‚è¡¥ä¸æ¨èç»„ä»¶å‘å¼€å‘äººå‘˜æ¨èå€™é€‰çš„è¡¥ä¸ï¼Œå¹¶æ”¶é›†ä»–ä»¬çš„åé¦ˆã€‚å®ƒåˆ é™¤å¼€å‘äººå‘˜æ‹’ç»çš„è¡¥ä¸ï¼Œå¹¶åŒ…æ‹¬å¼€å‘äººå‘˜æäº¤çš„æ‰‹å·¥åˆ¶ä½œçš„è¡¥ä¸æ¨¡æ¿ï¼Œä»¥æ”¹è¿›è¡¥ä¸æ•°æ®åº“ã€‚

### 4.1 Patch Discovery

The offline patch discovery component performs three steps to generate patch templates: extracting defect-patch pairs, clustering defect-patch pairs, and collecting generic patch templates.

ç¦»çº¿è¡¥ä¸å‘ç°ç»„ä»¶æ‰§è¡Œä¸‰ä¸ªæ­¥éª¤æ¥ç”Ÿæˆè¡¥ä¸æ¨¡æ¿:æå–ç¼ºé™·-è¡¥ä¸å¯¹ã€é›†ç¾¤ç¼ºé™·-è¡¥ä¸å¯¹å’Œæ”¶é›†é€šç”¨è¡¥ä¸æ¨¡æ¿ã€‚

#### 4.1.1 Extracting Defect-Patch Pairs.

The first step is to extract a large number of defect-patch pairs from the codebase. We make two improvements to the SZZ algorithm, to adapt to the needs of the industrial codebase.

ç¬¬ä¸€æ­¥æ˜¯ä»ä»£ç åº“ä¸­æå–å¤§é‡ç¼ºé™·-è¡¥ä¸å¯¹ã€‚æˆ‘ä»¬å¯¹SZZç®—æ³•åšäº†ä¸¤ä¸ªæ”¹è¿›ï¼Œä»¥é€‚åº”å·¥ä¸šä»£ç åº“çš„éœ€è¦ã€‚

- Constraining the Number of Changed Files. 
The first adjustment is to set a threshold on the number of files modified in a bug-fixing commit, filtering out any commit that exceed the threshold. In this way, we could reduce the false positives that are caused by multi-purpose commits (C.f. Sect. 3). We heuristically chose five as the threshold, which help reduce false positives without discarding too many candidate commits (22.7% as indicated in Fig. 1).

ç¬¬ä¸€ä¸ªè°ƒæ•´æ˜¯å¯¹ä¿®å¤bugæäº¤ä¸­ä¿®æ”¹çš„æ–‡ä»¶æ•°é‡è®¾ç½®é˜ˆå€¼ï¼Œè¿‡æ»¤æ‰ä»»ä½•è¶…è¿‡é˜ˆå€¼çš„æäº¤ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å‡å°‘ç”±å¤šç›®çš„æäº¤æ‰€å¯¼è‡´çš„è¯¯æŠ¥(c.f. . 3èŠ‚)ã€‚æˆ‘ä»¬å¯å‘å¼åœ°é€‰æ‹©5ä¸ªä½œä¸ºé˜ˆå€¼ï¼Œè¿™æœ‰åŠ©äºå‡å°‘è¯¯æŠ¥ï¼ŒåŒæ—¶åˆä¸æ”¾å¼ƒå¤ªå¤šçš„å€™é€‰æäº¤(22.7%ï¼Œå¦‚å›¾1æ‰€ç¤º)ã€‚

- Identifying Bug-Inducing Code Snippets. 
The second improvement aims to improve the precision of identifying bug-inducing changes. As studied in Sect. 3, commit-level back-tracing in history tends to be imprecise, especially when there are many multipurpose commits contributing to the defect.

ç¬¬äºŒä¸ªæ”¹è¿›æ˜¯ä¸ºäº†æé«˜è¯†åˆ«å¼•èµ·bugçš„å˜åŒ–çš„ç²¾åº¦ã€‚æ­£å¦‚åœ¨ç¬¬3èŠ‚ä¸­æ‰€ç ”ç©¶çš„ï¼Œå†å²ä¸Šçš„å§”å‘˜ä¼šçº§åˆ«çš„å›æº¯å¾€å¾€æ˜¯ä¸ç²¾ç¡®çš„ï¼Œç‰¹åˆ«æ˜¯å½“æœ‰è®¸å¤šå¤šç”¨é€”çš„æäº¤å¯¼è‡´ç¼ºé™·æ—¶ã€‚

Therefore, instead of tracing commits back in time and identifying bug-inducing commits, we directly identify bug-inducing code snippets. In fact, the differences before and after the introduction of a bug-fixing commit already contain information about both the defects and the patches. Now we describe the improved method-level defect-patch pair extraction in more details.

å› æ­¤ï¼Œæˆ‘ä»¬ç›´æ¥è¯†åˆ«å¯¼è‡´bugçš„ä»£ç ç‰‡æ®µï¼Œè€Œä¸æ˜¯åŠæ—¶è·Ÿè¸ªæäº¤å’Œè¯†åˆ«å¯¼è‡´bugçš„æäº¤ã€‚å®é™…ä¸Šï¼Œåœ¨å¼•å…¥bugä¿®å¤æäº¤ä¹‹å‰å’Œä¹‹åçš„å·®å¼‚å·²ç»åŒ…å«äº†å…³äºç¼ºé™·å’Œè¡¥ä¸çš„ä¿¡æ¯ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å°†æ›´è¯¦ç»†åœ°æè¿°æ”¹è¿›çš„æ–¹æ³•çº§ç¼ºé™·-è¡¥ä¸å¯¹æå–ã€‚

- Method-Level Defect-Patch Pair Extraction. 
To further reduce false positives, we constrain the defects and patches as the removed and inserted lines in a bug-fixing commit, respectively. We confine the scope of defects and patches to be within a single method. Of course, these constraints may rule out some genuine defect-patch pairs, e.g., patches only removing old lines or inserting new lines. Our current bug-fix model balances between the completeness and accuracy, attempting to be simple but applicable to the most common cases.We randomly sampled 90 bug fixes from the benchmark set and confirmed that 68 (76%) of them contain both removed and inserted lines, which fall into our simplified bug model. We found in practice that the compromises made in the recall (24%) help significantly improve the precision.

ä¸ºäº†è¿›ä¸€æ­¥å‡å°‘è¯¯æŠ¥ï¼Œæˆ‘ä»¬åˆ†åˆ«åœ¨bugä¿®å¤æäº¤ä¸­åˆ é™¤å’Œæ’å…¥çš„è¡Œæ—¶çº¦æŸç¼ºé™·å’Œè¡¥ä¸ã€‚æˆ‘ä»¬å°†ç¼ºé™·å’Œè¡¥ä¸çš„èŒƒå›´é™åˆ¶åœ¨å•ä¸€æ–¹æ³•ä¹‹å†…ã€‚å½“ç„¶ï¼Œè¿™äº›çº¦æŸå¯èƒ½ä¼šæ’é™¤ä¸€äº›çœŸæ­£çš„ç¼ºé™·-è¡¥ä¸å¯¹ï¼Œä¾‹å¦‚ï¼Œè¡¥ä¸åªåˆ é™¤æ—§è¡Œæˆ–æ’å…¥æ–°è¡Œã€‚æˆ‘ä»¬å½“å‰çš„bugä¿®å¤æ¨¡å‹åœ¨å®Œæ•´æ€§å’Œå‡†ç¡®æ€§ä¹‹é—´ä¿æŒå¹³è¡¡ï¼Œè¯•å›¾ç®€å•ä½†é€‚ç”¨äºæœ€å¸¸è§çš„æƒ…å†µã€‚æˆ‘ä»¬ä»åŸºå‡†æµ‹è¯•é›†ä¸­éšæœºæŠ½æ ·90ä¸ªbugä¿®å¤ï¼Œå¹¶ç¡®è®¤å…¶ä¸­68ä¸ª(76%)åŒ…å«åˆ é™¤å’Œæ’å…¥çš„è¡Œï¼Œå®ƒä»¬å±äºæˆ‘ä»¬ç®€åŒ–çš„bugæ¨¡å‹ã€‚æˆ‘ä»¬åœ¨å®è·µä¸­å‘ç°ï¼Œå¬å›ä¸­åšå‡ºçš„å¦¥å(24%)æœ‰åŠ©äºæ˜¾è‘—æé«˜å‡†ç¡®æ€§ã€‚

Given a bug-fixing commit and the source code of the project, the workflow of extracting defect-patch pairs is the following. 
(1) Check out the last-updated snapshot before the bug-fixing commit and record inserted and removed lines in the commit for later parsing. 
(2) Extract inserted lines in the commit, which are patch snippets. 
(3) Extract removed lines in the commit, which are defect snippets. 
(4) Associate each defect snippet with the corresponding patch snippet, forming defect-patch pairs. 
(5) Filter out the lines of defect snippets that are not in the same method scope as any patch lines, making defect-patch pairs more cohesive. 
(6) Filter out assertion lines, comments, and logging lines from the defect-patch pairs as they are generally irrelevant to bug fixes. At this point, we have obtained a set of defect-patch pairs, on which we perform the remaining steps of the patch discovery.

ç»™å®šä¿®å¤é”™è¯¯çš„æäº¤å’Œé¡¹ç›®çš„æºä»£ç ï¼Œæå–ç¼ºé™·-è¡¥ä¸å¯¹çš„å·¥ä½œæµç¨‹å¦‚ä¸‹ã€‚
(1)åœ¨æäº¤ä¿®å¤bugä¹‹å‰æ£€æŸ¥æœ€åæ›´æ–°çš„å¿«ç…§ï¼Œå¹¶åœ¨æäº¤ä¸­æ’å…¥å’Œåˆ é™¤è®°å½•ï¼Œä»¥ä¾¿ä»¥åè¿›è¡Œè§£æã€‚
(2)æå–æäº¤ä¸­æ’å…¥çš„è¡Œï¼Œè¿™äº›è¡Œæ˜¯è¡¥ä¸ç‰‡æ®µã€‚
(3)æå–æäº¤ä¸­è¢«åˆ é™¤çš„è¡Œï¼Œå®ƒä»¬æ˜¯ç¼ºé™·ç‰‡æ®µã€‚
(4)å°†æ¯ä¸ªç¼ºé™·ç‰‡æ®µä¸å¯¹åº”çš„è¡¥ä¸ç‰‡æ®µç›¸å…³è”ï¼Œå½¢æˆç¼ºé™·-è¡¥ä¸å¯¹ã€‚
(5)è¿‡æ»¤æ‰ä¸ä»»ä½•ä¿®è¡¥ç¨‹åºä¸åœ¨åŒä¸€æ–¹æ³•èŒƒå›´å†…çš„ç¼ºé™·ç‰‡æ®µçš„è¡Œï¼Œä½¿ç¼ºé™·-ä¿®è¡¥ç¨‹åºå¯¹æ›´å…·å†…èšæ€§ã€‚
(6)ä»ç¼ºé™·-è¡¥ä¸å¯¹ä¸­è¿‡æ»¤æ‰æ–­è¨€è¡Œã€æ³¨é‡Šå’Œæ—¥å¿—è¡Œï¼Œå› ä¸ºå®ƒä»¬é€šå¸¸ä¸bugä¿®å¤ä¸ç›¸å…³ã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬å·²ç»è·å¾—äº†ä¸€ç»„ç¼ºé™·-è¡¥ä¸å¯¹ï¼Œæˆ‘ä»¬å°†åœ¨å…¶ä¸Šæ‰§è¡Œè¡¥ä¸å‘ç°çš„å…¶ä½™æ­¥éª¤ã€‚

#### 4.1.2 Clustering Defect-Patch Pairs. 

To obtain common defects patterns in the codebase, we group all the extracted defect-patch pairs into a set of clusters. We use density-based spatial clustering of applications with noise (DBSCAN) [9] as our clustering algorithm. DBSCAN is a wellestablished clustering method without the need to determine the number of clusters (ğ¾) in advance. Given a set of points in some vector space, DBSCAN groups points that are closely packed together (nearby neighbors), marking as outliers those points that lie in low-density regions. We choose DBSCAN instead of other clustering algorithms, such as KNN [8] and ğ¾-means, because in our case, the number ğ¾ could not be known in advance. A well known limitation of the vanilla DBSCAN algorithm is that it is computationally expensive when coping with large-scale dataset [37], since it considers all possible comparisons between every data point. In our application scenario, most of the comparisons are unnecessary, as many code snippets are very loosely related. Therefore, we make three customized improvements to DBSCAN to mitigate this issue.

ä¸ºäº†è·å¾—ä»£ç åº“ä¸­å¸¸è§çš„ç¼ºé™·æ¨¡å¼ï¼Œæˆ‘ä»¬å°†æ‰€æœ‰æå–çš„ç¼ºé™·-è¡¥ä¸å¯¹åˆ†ç»„åˆ°ä¸€ç»„é›†ç¾¤ä¸­ã€‚æˆ‘ä»¬ä½¿ç”¨åŸºäºå¯†åº¦çš„ç©ºé—´èšç±»åº”ç”¨ç¨‹åºä¸å™ªå£°(DBSCAN)[9]ä½œä¸ºæˆ‘ä»¬çš„èšç±»ç®—æ³•ã€‚DBSCANæ˜¯ä»–èšç±»æ–¹æ³•è€Œä¸éœ€è¦äº‹å…ˆç¡®å®šé›†ç¾¤(ğ¾)çš„æ•°é‡ã€‚ç»™å®šæŸä¸ªå‘é‡ç©ºé—´ä¸­çš„ä¸€ç»„ç‚¹ï¼ŒDBSCANå°†ç´§æŒ¨åœ¨ä¸€èµ·çš„ç‚¹(é‚»è¿‘çš„ç‚¹)åˆ†ç»„ï¼Œå°†ä½äºä½å¯†åº¦åŒºåŸŸçš„ç‚¹æ ‡è®°ä¸ºç¦»ç¾¤ç‚¹ã€‚æˆ‘ä»¬é€‰æ‹©DBSCANä»£æ›¿å…¶ä»–èšç±»ç®—æ³•,å¦‚èµ„è®¯[8]å’Œğ¾-means,å› ä¸ºåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­,ğ¾æ•°é‡ä¸èƒ½æå‰çŸ¥é“ã€‚æ™®é€šDBSCANç®—æ³•çš„ä¸€ä¸ªä¼—æ‰€å‘¨çŸ¥çš„å±€é™æ€§æ˜¯ï¼Œå½“å¤„ç†å¤§å‹æ•°æ®é›†[37]æ—¶ï¼Œå®ƒçš„è®¡ç®—å¼€é”€éå¸¸å¤§ï¼Œå› ä¸ºå®ƒè€ƒè™‘äº†æ¯ä¸ªæ•°æ®ç‚¹ä¹‹é—´æ‰€æœ‰å¯èƒ½çš„æ¯”è¾ƒã€‚åœ¨æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºåœºæ™¯ä¸­ï¼Œå¤§å¤šæ•°æ¯”è¾ƒéƒ½æ˜¯ä¸å¿…è¦çš„ï¼Œå› ä¸ºè®¸å¤šä»£ç ç‰‡æ®µéƒ½æ˜¯æ¾æ•£ç›¸å…³çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯¹DBSCANåšäº†ä¸‰ä¸ªå®šåˆ¶çš„æ”¹è¿›æ¥ç¼“è§£è¿™ä¸ªé—®é¢˜ã€‚

- Utilizing SimHash-KDTree Reducers. 
The first customization is to use SimHash-KDTree reducers to avoid the comparison of some irrelevant data points. SimHash [33] is an algorithm that generates a low-dimensional vector signature for any high-dimensional vector. The generated low-dimensional vector has the same expressiveness as the original high-dimensional vector, but is shorter in length, thus enables faster comparison. During preprocessing, we use the SimHash algorithm to map the contents of code snippets to 16-bit hashcode sequences. Then we run the KDTree algorithm [4] to group all the sequences that have a Hamming distance less than 4 into the same reducer. During the clustering, we only compute similarity of code snippets in the same reducer.

ç¬¬ä¸€ä¸ªå®šåˆ¶æ˜¯ä½¿ç”¨simhashk - kdtreeçº¦ç®€å™¨æ¥é¿å…å¯¹ä¸€äº›ä¸ç›¸å…³çš„æ•°æ®ç‚¹è¿›è¡Œæ¯”è¾ƒã€‚SimHash[33]æ˜¯ä¸€ç§ä¸ºä»»ä½•é«˜ç»´å‘é‡ç”Ÿæˆä½ç»´å‘é‡ç­¾åçš„ç®—æ³•ã€‚ç”Ÿæˆçš„ä½ç»´å‘é‡å…·æœ‰ä¸åŸå§‹é«˜ç»´å‘é‡ç›¸åŒçš„è¡¨è¾¾èƒ½åŠ›ï¼Œä½†æ˜¯é•¿åº¦æ›´çŸ­ï¼Œå› æ­¤å¯ä»¥æ›´å¿«åœ°è¿›è¡Œæ¯”è¾ƒã€‚åœ¨é¢„å¤„ç†æœŸé—´ï¼Œæˆ‘ä»¬ä½¿ç”¨SimHashç®—æ³•å°†ä»£ç ç‰‡æ®µçš„å†…å®¹æ˜ å°„åˆ°16ä½hashcodeåºåˆ—ã€‚ç„¶åæˆ‘ä»¬è¿è¡ŒKDTreeç®—æ³•[4]å°†æ‰€æœ‰æ±‰æ˜è·ç¦»å°äº4çš„åºåˆ—åˆ†ç»„åˆ°åŒä¸€ä¸ªå‡é€Ÿæœºä¸­ã€‚åœ¨èšç±»çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬åªè®¡ç®—åŒä¸€å‡é€Ÿæœºä¸­ä»£ç ç‰‡æ®µçš„ç›¸ä¼¼åº¦ã€‚

- Exploiting API Sequence Information. 
The second improvement is to exploit the information from API call sequences to avoid irrelevant comparisons. The intuition behind this is that if two code snippets contain two completely different API call sequences, then they are obviously not belonging to the same patch pattern, thus should not be compared during the clustering. Therefore, we parse the ASTs of defect-patch pairs and extract API call sequences for each code snippet in advance. During clustering, even if two code snippets are in the same reducer, as long as their API call sequences do not match, we skip the comparison of them.We name this filtering process as APISeq.

ç¬¬äºŒä¸ªæ”¹è¿›æ˜¯åˆ©ç”¨APIè°ƒç”¨åºåˆ—ä¸­çš„ä¿¡æ¯æ¥é¿å…ä¸ç›¸å…³çš„æ¯”è¾ƒã€‚è¿™èƒŒåçš„ç›´è§‰æ˜¯ï¼Œå¦‚æœä¸¤ä¸ªä»£ç ç‰‡æ®µåŒ…å«ä¸¤ä¸ªå®Œå…¨ä¸åŒçš„APIè°ƒç”¨åºåˆ—ï¼Œé‚£ä¹ˆå®ƒä»¬æ˜¾ç„¶ä¸å±äºåŒä¸€è¡¥ä¸æ¨¡å¼ï¼Œå› æ­¤ä¸åº”è¯¥åœ¨é›†ç¾¤æœŸé—´è¿›è¡Œæ¯”è¾ƒã€‚å› æ­¤ï¼Œæˆ‘ä»¬è§£æç¼ºé™·-è¡¥ä¸å¯¹çš„astï¼Œå¹¶é¢„å…ˆä¸ºæ¯ä¸ªä»£ç ç‰‡æ®µæå–APIè°ƒç”¨åºåˆ—ã€‚åœ¨é›†ç¾¤è¿‡ç¨‹ä¸­ï¼Œå³ä½¿ä¸¤ä¸ªä»£ç ç‰‡æ®µä½äºç›¸åŒçš„å‡é€Ÿå™¨ä¸­ï¼Œåªè¦å®ƒä»¬çš„APIè°ƒç”¨åºåˆ—ä¸åŒ¹é…ï¼Œæˆ‘ä»¬å°±ä¼šè·³è¿‡å¯¹å®ƒä»¬çš„æ¯”è¾ƒã€‚æˆ‘ä»¬å°†è¿™ä¸ªè¿‡æ»¤è¿‡ç¨‹å‘½åä¸ºAPISeqã€‚

- Normalizing Code Snippets. 
We also improve the clustering accuracy of DBSCAN by normalizing code snippets. Some common coding patterns have multiple equivalent ways of expression. These ways, although semantically equivalent, are syntactically different, which decreases the accuracy of clustering. For instance, a string value could be expressed as either a single string literal or the concatenation of several string literals. When we compare code snippets, we want to consider these equivalent expressions as the same. Therefore, we normalize the code snippets to convert these semantically equivalent snippets into syntactically same format. Our normalization rules are as follows: (1) merge consecutive calls of the same API into one API call sequence, concatenated by the dot (â€œ.â€) operator; (2) change â€œ.append(string)â€ to the concatenation of strings; and (3) merge the concatenation of strings into a single string.

æˆ‘ä»¬è¿˜é€šè¿‡è§„èŒƒåŒ–ä»£ç ç‰‡æ®µæ¥æé«˜DBSCANçš„èšç±»ç²¾åº¦ã€‚ä¸€äº›å¸¸è§çš„ç¼–ç æ¨¡å¼æœ‰å¤šç§ç­‰ä»·çš„è¡¨è¾¾æ–¹å¼ã€‚è¿™äº›æ–¹æ³•è™½ç„¶åœ¨è¯­ä¹‰ä¸Šæ˜¯ç­‰ä»·çš„ï¼Œä½†åœ¨è¯­æ³•ä¸Šæ˜¯ä¸åŒçš„ï¼Œè¿™å°±é™ä½äº†èšç±»çš„å‡†ç¡®æ€§ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå­—ç¬¦ä¸²å€¼å¯ä»¥è¡¨ç¤ºä¸ºå•ä¸ªå­—ç¬¦ä¸²æ–‡å­—ï¼Œä¹Ÿå¯ä»¥è¡¨ç¤ºä¸ºå‡ ä¸ªå­—ç¬¦ä¸²æ–‡å­—çš„è¿æ¥ã€‚åœ¨æ¯”è¾ƒä»£ç æ®µæ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›å°†è¿™äº›ç­‰æ•ˆè¡¨è¾¾å¼è§†ä¸ºç›¸åŒçš„è¡¨è¾¾å¼ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯¹ä»£ç ç‰‡æ®µè¿›è¡Œè§„èŒƒåŒ–ï¼Œå°†è¿™äº›è¯­ä¹‰ä¸Šç­‰ä»·çš„ä»£ç ç‰‡æ®µè½¬æ¢ä¸ºè¯­æ³•ä¸Šç›¸åŒçš„æ ¼å¼ã€‚æˆ‘ä»¬çš„è§„èŒƒåŒ–è§„åˆ™å¦‚ä¸‹:(1)å°†åŒä¸€APIçš„è¿ç»­è°ƒç”¨åˆå¹¶ä¸ºä¸€ä¸ªAPIè°ƒç”¨åºåˆ—ï¼Œå¹¶ç”±ç‚¹(" . ")æ“ä½œç¬¦è¿æ¥;(2)å°†â€œ.append(string)â€æ”¹ä¸ºå­—ç¬¦ä¸²çš„æ‹¼æ¥;(3)å°†å­—ç¬¦ä¸²ä¸²æ¥åˆå¹¶æˆä¸€ä¸ªå­—ç¬¦ä¸²ã€‚

DBSCAN computes the distance between two defect-patch pairs based on their similarity. The computation of similarity is described in Algorithm 1. Given two defect-patch pairs, the algorithm first checks whether they are in the same reducer. The reducers are obtained using the customized hashing algorithm (SimHash + KDTree). If they are not in the same reducer, then the similarity computation is skipped (Line 2). Otherwise, the algorithm invokes APISeq, additional filtering based on the API sequence used, on each defect-patch pair to extract API sequences (Lines 3-4). If there is no intersection between the two API sequences, the algorithm also skips the similarity computation (Line 6).

DBSCANæ ¹æ®ç¼ºé™·ä¿®è¡¥å¯¹ä¹‹é—´çš„ç›¸ä¼¼æ€§è®¡ç®—å®ƒä»¬ä¹‹é—´çš„è·ç¦»ã€‚ç®—æ³•1æè¿°äº†ç›¸ä¼¼åº¦çš„è®¡ç®—ã€‚ç»™å®šä¸¤ä¸ªç¼ºé™·-è¡¥ä¸å¯¹ï¼Œç®—æ³•é¦–å…ˆæ£€æŸ¥å®ƒä»¬æ˜¯å¦åœ¨åŒä¸€ä¸ªå‡é€Ÿæœºä¸­ã€‚ä½¿ç”¨å®šåˆ¶çš„å“ˆå¸Œç®—æ³•(SimHash + KDTree)è·å¾—çº¦ç®€ã€‚å¦‚æœå®ƒä»¬ä¸åœ¨åŒä¸€ä¸ªreduceä¸­ï¼Œåˆ™è·³è¿‡ç›¸ä¼¼åº¦è®¡ç®—(ç¬¬2è¡Œ)ï¼Œå¦åˆ™ï¼Œç®—æ³•è°ƒç”¨APISeqï¼Œæ ¹æ®ä½¿ç”¨çš„APIåºåˆ—å¯¹æ¯ä¸ªç¼ºé™·-è¡¥ä¸å¯¹è¿›è¡Œé¢å¤–çš„è¿‡æ»¤ï¼Œæå–APIåºåˆ—(ç¬¬3-4è¡Œ)ã€‚å¦‚æœä¸¤ä¸ªAPIåºåˆ—ä¹‹é—´æ²¡æœ‰äº¤é›†ï¼Œç®—æ³•ä¹Ÿä¼šè·³è¿‡ç›¸ä¼¼åº¦è®¡ç®—(ç¬¬6è¡Œ)ã€‚

The remaining defect-patch pairs after the filtering proceed to the similarity computation. The similarity function we used in Algorithm 1 is a weighted sum of two similarity metrics: the Jaccard similarity coefficient [39] and the Levenshtein distance [25] (Lines 7-9). We choose these two similarity metrics because the Jaccard similarity coefficient is able to capture the token overlapping rate while the Levenshtein distance has the ability to capture the ordering information of the token list.

è¿‡æ»¤åçš„å‰©ä½™ç¼ºé™·-patchå¯¹è¿›è¡Œç›¸ä¼¼åº¦è®¡ç®—ã€‚æˆ‘ä»¬åœ¨ç®—æ³•1ä¸­ä½¿ç”¨çš„ç›¸ä¼¼åº¦å‡½æ•°æ˜¯ä¸¤ä¸ªç›¸ä¼¼åº¦åº¦é‡çš„åŠ æƒå’Œ:Jaccardç›¸ä¼¼ç³»æ•°[39]å’ŒLevenshteinè·ç¦»[25](ç¬¬7-9è¡Œ)ã€‚æˆ‘ä»¬é€‰æ‹©è¿™ä¸¤ä¸ªç›¸ä¼¼åº¦åº¦é‡æ˜¯å› ä¸ºJaccardç›¸ä¼¼ç³»æ•°èƒ½å¤Ÿæ•è·ä»¤ç‰Œé‡å ç‡ï¼Œè€ŒLevenshteinè·ç¦»èƒ½å¤Ÿæ•è·ä»¤ç‰Œåˆ—è¡¨çš„æ’åºä¿¡æ¯ã€‚

#### 4.1.3 Collecting Generic Patch Templates. 

After the clustering step finishes, for each pattern cluster, Precfix tries to extract a generic patch template, which summarizes the common pattern of defectpatch pairs in that cluster. Each template encodes a pattern of defect and its corresponding patch.

åœ¨é›†ç¾¤æ­¥éª¤å®Œæˆä¹‹åï¼Œå¯¹äºæ¯ä¸ªæ¨¡å¼é›†ç¾¤ï¼ŒPrecfixå°è¯•æå–ä¸€ä¸ªé€šç”¨çš„è¡¥ä¸æ¨¡æ¿ï¼Œè¯¥æ¨¡æ¿æ€»ç»“äº†è¯¥é›†ç¾¤ä¸­ç¼ºé™·è¡¥ä¸å¯¹çš„å¸¸è§æ¨¡å¼ã€‚æ¯ä¸ªæ¨¡æ¿ç¼–ç ä¸€ä¸ªç¼ºé™·æ¨¡å¼åŠå…¶ç›¸åº”çš„è¡¥ä¸ã€‚

The goal of template generalization is to make the patch generally applicable in different contexts and understandable to developers. Although all the defect-patch pairs from the same cluster are similar, they differ from each other in some context-specific way, e.g., variable names. We abstract away all context-specific contents and only preserve the generic templates.

æ¨¡æ¿æ³›åŒ–çš„ç›®æ ‡æ˜¯ä½¿è¡¥ä¸æ™®éé€‚ç”¨äºä¸åŒçš„ç¯å¢ƒï¼Œå¹¶ä½¿å¼€å‘äººå‘˜èƒ½å¤Ÿç†è§£ã€‚å°½ç®¡æ¥è‡ªåŒä¸€é›†ç¾¤çš„æ‰€æœ‰ç¼ºé™·-è¡¥ä¸å¯¹éƒ½æ˜¯ç±»ä¼¼çš„ï¼Œä½†å®ƒä»¬åœ¨æŸäº›ç‰¹å®šäºä¸Šä¸‹æ–‡çš„æ–¹å¼(ä¾‹å¦‚å˜é‡å)ä¸Šæ˜¯ä¸åŒçš„ã€‚æˆ‘ä»¬æŠ½è±¡äº†æ‰€æœ‰ä¸Šä¸‹æ–‡ç›¸å…³çš„å†…å®¹ï¼Œåªä¿ç•™äº†é€šç”¨æ¨¡æ¿ã€‚

The first step of template generalization is to convert code lines into a list of tokens, each token is either a symbol or a parameter. Symbols are context-independent, they together form the common patterns among all the defect-patch pairs in a cluster; parameters are context-specific that represent the abstraction of variable names. When a template is applied at a specific context, its parameters are supposed to be replaced by the actual variable names.

æ¨¡æ¿æ³›åŒ–çš„ç¬¬ä¸€æ­¥æ˜¯å°†ä»£ç è¡Œè½¬æ¢ä¸ºä»¤ç‰Œåˆ—è¡¨ï¼Œæ¯ä¸ªä»¤ç‰Œè¦ä¹ˆæ˜¯ä¸€ä¸ªç¬¦å·ï¼Œè¦ä¹ˆæ˜¯ä¸€ä¸ªå‚æ•°ã€‚ç¬¦å·æ˜¯ä¸ä¸Šä¸‹æ–‡æ— å…³çš„ï¼Œå®ƒä»¬å…±åŒæ„æˆä¸€ä¸ªç°‡ä¸­æ‰€æœ‰ç¼ºé™·-è¡¥ä¸å¯¹çš„å…±åŒæ¨¡å¼;å‚æ•°æ˜¯ç‰¹å®šäºä¸Šä¸‹æ–‡çš„ï¼Œè¡¨ç¤ºå˜é‡åç§°çš„æŠ½è±¡ã€‚å½“æ¨¡æ¿åº”ç”¨äºç‰¹å®šçš„ä¸Šä¸‹æ–‡æ—¶ï¼Œå®ƒçš„å‚æ•°åº”è¯¥ç”±å®é™…çš„å˜é‡åæ›¿æ¢ã€‚

The second step is to extract templates from the token lists. We use the recursive longest common substring (RLCS) algorithm [15] to perform matching between token lists. RLCS recursively calls longest common substring matching until all the tokens are matched. The highlighted parts in Fig. 4 are the matched tokens after the RLCS process (Step 1). We adjust the vanilla RLCS so that different parameter names are not matched while the other symbols are. Finally, we collect all the parameter names that are matched in the same cluster to a list and store them in our self-defined parameter format. Step 2 in Fig. 4 shows that different parameter names are recognized and collected, and stored in the standard format: @ğ‘ƒğ‘ğ‘Ÿğ‘{parameter name list}.

ç¬¬äºŒæ­¥æ˜¯ä»ä»¤ç‰Œåˆ—è¡¨ä¸­æå–æ¨¡æ¿ã€‚æˆ‘ä»¬ä½¿ç”¨é€’å½’æœ€é•¿å…¬å…±å­ä¸²(RLCS)ç®—æ³•[15]æ¥æ‰§è¡Œä»¤ç‰Œåˆ—è¡¨ä¹‹é—´çš„åŒ¹é…ã€‚RLCSé€’å½’åœ°è°ƒç”¨æœ€é•¿å…¬å…±å­å­—ç¬¦ä¸²åŒ¹é…ï¼Œç›´åˆ°æ‰€æœ‰æ ‡è®°éƒ½åŒ¹é…ä¸ºæ­¢ã€‚å›¾4ä¸­çªå‡ºæ˜¾ç¤ºçš„éƒ¨åˆ†æ˜¯ç»è¿‡RLCSå¤„ç†(æ­¥éª¤1)ååŒ¹é…çš„æ ‡è®°ã€‚æœ€åï¼Œæˆ‘ä»¬å°†åŒä¸€é›†ç¾¤ä¸­åŒ¹é…çš„æ‰€æœ‰å‚æ•°åç§°æ”¶é›†åˆ°ä¸€ä¸ªåˆ—è¡¨ä¸­ï¼Œå¹¶å°†å®ƒä»¬å­˜å‚¨ä¸ºè‡ªå®šä¹‰å‚æ•°æ ¼å¼ã€‚æ­¥éª¤2çš„å›¾4æ˜¾ç¤ºäº†ä¸åŒçš„å‚æ•°åç§°è¯†åˆ«å’Œæ”¶é›†,å¹¶å­˜å‚¨åœ¨æ ‡å‡†æ ¼å¼:@ğ‘ƒğ‘ğ‘Ÿğ‘}{å‚æ•°åç§°åˆ—è¡¨ã€‚

Finally, for each defect-patch pair, we change the parameter names in the patch snippet to match the parameter names in the corresponding defect snippet. After this step, Precfix constructs a patch template database, which contains all the extracted templates.

æœ€åï¼Œå¯¹äºæ¯ä¸€ä¸ªç¼ºé™·-è¡¥ä¸å¯¹ï¼Œæˆ‘ä»¬æ”¹å˜è¡¥ä¸ç‰‡æ®µä¸­çš„å‚æ•°åç§°æ¥åŒ¹é…ç›¸åº”ç¼ºé™·ç‰‡æ®µä¸­çš„å‚æ•°åç§°ã€‚åœ¨æ­¤æ­¥éª¤ä¹‹åï¼ŒPrecfixæ„å»ºä¸€ä¸ªè¡¥ä¸æ¨¡æ¿æ•°æ®åº“ï¼Œå…¶ä¸­åŒ…å«æ‰€æœ‰æå–çš„æ¨¡æ¿ã€‚

### 4.2 Patch Recommendation

The online patch recommendation component is triggered whenever developers commit new code changes. During code review, Precfix matches each of developersâ€™ newly committed code snippet with the templates database. If a code snippet matches with a template, Precfix replaces the generic parameter placeholders in the template with the actual parameter names used in the specific contexts. If multiple templates are matched, they are ranked based on the frequency of the corresponding defect-patch pairs before clustering. By default, Precfix recommends the most popular patch candidate. The patch candidate is then sent to the code submitters and reviewers for feedback.We collect feedback from developers to validate the patch candidates and improve the template database of Precfix. More specifically, the defects and the corresponding recommended patches are presented to the developers. As developers inspect each recommended patch, we also collect their reactions on the patch, i.e., accept or reject. If patches from a certain template are frequently rejected, we will manually inspect the template and decide whether to remove it.

åªè¦å¼€å‘äººå‘˜æäº¤æ–°çš„ä»£ç æ›´æ”¹ï¼Œåœ¨çº¿è¡¥ä¸æ¨èç»„ä»¶å°±ä¼šè¢«è§¦å‘ã€‚åœ¨ä»£ç å®¡æŸ¥æœŸé—´ï¼ŒPrecfixå°†æ¯ä¸ªå¼€å‘äººå‘˜æ–°æäº¤çš„ä»£ç ç‰‡æ®µä¸æ¨¡æ¿æ•°æ®åº“è¿›è¡ŒåŒ¹é…ã€‚å¦‚æœä»£ç æ®µä¸æ¨¡æ¿åŒ¹é…ï¼ŒPrecfixå°†æ¨¡æ¿ä¸­çš„é€šç”¨å‚æ•°å ä½ç¬¦æ›¿æ¢ä¸ºåœ¨ç‰¹å®šä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨çš„å®é™…å‚æ•°åã€‚å¦‚æœåŒ¹é…å¤šä¸ªæ¨¡æ¿ï¼Œåˆ™åœ¨èšç±»ä¹‹å‰æ ¹æ®ç›¸åº”ç¼ºé™·-è¡¥ä¸å¯¹çš„é¢‘ç‡å¯¹å®ƒä»¬è¿›è¡Œæ’åºã€‚é»˜è®¤æƒ…å†µä¸‹ï¼ŒPrecfixæ¨èæœ€æµè¡Œçš„è¡¥ä¸å€™é€‰ã€‚ç„¶åå°†å€™é€‰è¡¥ä¸å‘é€ç»™ä»£ç æäº¤è€…å’Œè¯„å®¡è€…ä»¥è·å¾—åé¦ˆã€‚æˆ‘ä»¬æ”¶é›†å¼€å‘äººå‘˜çš„åé¦ˆæ¥éªŒè¯å€™é€‰è¡¥ä¸å¹¶æ”¹è¿›Precfixçš„æ¨¡æ¿æ•°æ®åº“ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œç¼ºé™·å’Œç›¸åº”çš„æ¨èè¡¥ä¸è¢«å‘ˆç°ç»™å¼€å‘äººå‘˜ã€‚å½“å¼€å‘äººå‘˜æ£€æŸ¥æ¯ä¸ªæ¨èçš„è¡¥ä¸æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿæ”¶é›†ä»–ä»¬å¯¹è¡¥ä¸çš„ååº”ï¼Œå³ï¼Œæ¥å—æˆ–æ‹’ç»ã€‚å¦‚æœæŸä¸ªæ¨¡æ¿çš„è¡¥ä¸ç»å¸¸è¢«æ‹’ç»ï¼Œæˆ‘ä»¬å°†æ‰‹åŠ¨æ£€æŸ¥è¯¥æ¨¡æ¿å¹¶å†³å®šæ˜¯å¦åˆ é™¤å®ƒã€‚

During the patch validation process, in addition to feedback on the recommended patches, Precfix also accepts patch templates created by developers and is able to integrate them into Precfixâ€™s template database. We encourage developers to make custom adjustments to the existing patches or build their own patch templates based on their experience. We believe this contribution mechanism can enrich the template database in the long run.

åœ¨è¡¥ä¸éªŒè¯è¿‡ç¨‹ä¸­ï¼Œé™¤äº†å¯¹æ¨èçš„è¡¥ä¸æä¾›åé¦ˆå¤–ï¼ŒPrecfixè¿˜æ¥å—å¼€å‘äººå‘˜åˆ›å»ºçš„è¡¥ä¸æ¨¡æ¿ï¼Œå¹¶èƒ½å¤Ÿå°†å®ƒä»¬é›†æˆåˆ°Precfixçš„æ¨¡æ¿æ•°æ®åº“ä¸­ã€‚æˆ‘ä»¬é¼“åŠ±å¼€å‘äººå‘˜å¯¹ç°æœ‰è¡¥ä¸è¿›è¡Œè‡ªå®šä¹‰è°ƒæ•´ï¼Œæˆ–è€…æ ¹æ®ä»–ä»¬çš„ç»éªŒæ„å»ºè‡ªå·±çš„è¡¥ä¸æ¨¡æ¿ã€‚æˆ‘ä»¬ç›¸ä¿¡ï¼Œä»é•¿è¿œæ¥çœ‹ï¼Œè¿™ç§è´¡çŒ®æœºåˆ¶å¯ä»¥ä¸°å¯Œæ¨¡æ¿æ•°æ®åº“ã€‚

Fig. 5 shows the Precfix user interface for patch recommendation. Developers interact with it during code reviews. Fig. 5(a) shows the inline view of an identified defect and the corresponding patch recommended. Fig. 5(b) shows the detailed view of the defect-patch pairs (left) and the developer template suggestion form (right). The left side shows the list of defect-patch pairs from which the recommended template was extracted. The details of each defect-patch pair can be expanded, viewed, and voted for or against. Specifically, the two records shown in Fig. 5(b) are from
the files â€œ.../Rec***dler.javaâ€ and â€œ.../Trip***Impl.javaâ€, respectively. The right side is a form allowing developers to devise their own patches and submit to the database.

å›¾5ä¸ºpatchæ¨èçš„Precfixç”¨æˆ·ç•Œé¢ã€‚å¼€å‘äººå‘˜åœ¨ä»£ç è¯„å®¡æœŸé—´ä¸å®ƒäº¤äº’ã€‚å›¾5(a)æ˜¾ç¤ºäº†è¯†åˆ«ç¼ºé™·çš„å†…è”è§†å›¾å’Œæ¨èçš„ç›¸åº”è¡¥ä¸ã€‚å›¾5(b)æ˜¾ç¤ºäº†ç¼ºé™·-è¡¥ä¸å¯¹çš„è¯¦ç»†è§†å›¾(å·¦ä¾§)å’Œå¼€å‘äººå‘˜æ¨¡æ¿å»ºè®®è¡¨å•(å³ä¾§)ã€‚å·¦è¾¹æ˜¾ç¤ºäº†ç¼ºé™·-è¡¥ä¸å¯¹çš„åˆ—è¡¨ï¼Œä»å…¶ä¸­æå–äº†æ¨èçš„æ¨¡æ¿ã€‚æ¯ä¸ªç¼ºé™·è¡¥ä¸å¯¹çš„è¯¦ç»†ä¿¡æ¯å¯ä»¥å±•å¼€ã€æŸ¥çœ‹å¹¶æŠ•ç¥¨æ”¯æŒæˆ–åå¯¹ã€‚å…·ä½“æ¥è¯´ï¼Œå›¾5(b)ä¸­æ˜¾ç¤ºçš„ä¸¤æ¡è®°å½•æ¥è‡ªæ–‡ä»¶â€œâ€¦/Rec***dlerâ€ã€‚javaâ€å’Œâ€œ* * * Implâ€¦/æ—…è¡Œã€‚javaâ€,åˆ†åˆ«ã€‚å³ä¾§æ˜¯ä¸€ä¸ªè¡¨å•ï¼Œå…è®¸å¼€å‘äººå‘˜è®¾è®¡è‡ªå·±çš„è¡¥ä¸å¹¶æäº¤åˆ°æ•°æ®åº“ã€‚

## 5 IMPLEMENTATION AND EVALUATION

In this section, we describe the implementation details of Precfix and evaluate its effectiveness and efficiency on our benchmark set.

Precfix is implemented on top of the cloud-based data processing platform, MaxCompute [14], developed by Alibaba. The commit history data is preprocessed and stored in data tables on the Alibaba Cloud [13] storage first. The defect-patch pair extraction is implemented as a set of SQL scripts and user-defined functions (about 900 LOC). The clustering of defect-patch pairs is highly parallelized (taking about 1 KLOC Java code) and handled by the MapReduce engine of MaxCompute. The online patch recommendation component is integrated with the internal code review process and is triggered whenever a new commit is submitted.

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æè¿°Precfixçš„å®ç°ç»†èŠ‚ï¼Œå¹¶è¯„ä¼°å®ƒåœ¨åŸºå‡†é›†ä¸Šçš„æœ‰æ•ˆæ€§å’Œæ•ˆç‡ã€‚

Precfixæ˜¯åœ¨é˜¿é‡Œå·´å·´å¼€å‘çš„åŸºäºäº‘çš„æ•°æ®å¤„ç†å¹³å°MaxCompute[14]ä¸Šå®ç°çš„ã€‚æäº¤çš„å†å²æ•°æ®å…ˆè¢«é¢„å¤„ç†å¹¶å­˜å‚¨åœ¨é˜¿é‡Œå·´å·´äº‘[13]å­˜å‚¨çš„æ•°æ®è¡¨ä¸­ã€‚ç¼ºé™·-è¡¥ä¸å¯¹æå–æ˜¯ä½œä¸ºä¸€ç»„SQLè„šæœ¬å’Œç”¨æˆ·å®šä¹‰å‡½æ•°(å¤§çº¦900 LOC)å®ç°çš„ã€‚ç¼ºé™·-è¡¥ä¸å¯¹çš„é›†ç¾¤æ˜¯é«˜åº¦å¹¶è¡Œçš„(å¤§çº¦éœ€è¦1ä¸ªKLOC Javaä»£ç )ï¼Œç”±MaxComputeçš„MapReduceå¼•æ“å¤„ç†ã€‚åœ¨çº¿è¡¥ä¸æ¨èç»„ä»¶ä¸å†…éƒ¨ä»£ç å®¡æŸ¥æµç¨‹é›†æˆï¼Œå¹¶åœ¨æäº¤æ–°æäº¤æ—¶è§¦å‘ã€‚

The goal of our empirical evaluation is to answer the following research questions. RQ1: How effective is Precfix in locating defects and discovering patches? RQ2: How efficient is Precfix in recommending patches? RQ3: How much do our improvements of DBSCAN increase the efficiency of clustering? RQ4: What kind of patches does Precfix recommend? RQ5: What are the usersâ€™ opinions on the usability of Precfix?

æˆ‘ä»¬å®è¯è¯„ä¼°çš„ç›®çš„æ˜¯å›ç­”ä»¥ä¸‹ç ”ç©¶é—®é¢˜ã€‚RQ1: Precfixåœ¨å®šä½ç¼ºé™·å’Œå‘ç°è¡¥ä¸æ–¹é¢æœ‰å¤šæœ‰æ•ˆ?RQ2: Precfixåœ¨æ¨èè¡¥ä¸æ—¶çš„æ•ˆç‡å¦‚ä½•?RQ3:æˆ‘ä»¬å¯¹DBSCANçš„æ”¹è¿›åœ¨å¤šå¤§ç¨‹åº¦ä¸Šæé«˜äº†é›†ç¾¤çš„æ•ˆç‡?RQ4: Precfixæ¨èä»€ä¹ˆæ ·çš„è¡¥ä¸?RQ5:ç”¨æˆ·å¯¹Precfixçš„å¯ç”¨æ€§æœ‰ä»€ä¹ˆçœ‹æ³•?

We run the offline patch discovery component of Precfix on the randomly extracted sample dataset described in Sec 3. The sample dataset includes 10K projects, 15M commits, and 30M files. On this dataset, Precfix extracted 3K bug fix templates, forming the template database. During the clustering stage, 4,098 MB memory was allocated for each reducer.

æˆ‘ä»¬åœ¨sec3ä¸­æè¿°çš„éšæœºæŠ½å–çš„æ ·æœ¬æ•°æ®é›†ä¸Šè¿è¡ŒPrecfixçš„ç¦»çº¿è¡¥ä¸å‘ç°ç»„ä»¶ã€‚ç¤ºä¾‹æ•°æ®é›†åŒ…æ‹¬10Ké¡¹ç›®ã€15Mæäº¤å’Œ30Mæ–‡ä»¶ã€‚åœ¨è¿™ä¸ªæ•°æ®é›†ä¸Šï¼ŒPrecfixæå–äº†3K bugä¿®å¤æ¨¡æ¿ï¼Œå½¢æˆäº†æ¨¡æ¿æ•°æ®åº“ã€‚åœ¨é›†ç¾¤é˜¶æ®µï¼Œä¸ºæ¯ä¸ªå‡é€Ÿå™¨åˆ†é…äº†4,098 MBå†…å­˜ã€‚

## 6 CONCLUSION

In this paper, we present Precfix, a patch recommendation technique designed for large-scale industrial codebase. For patch discovery, Precfix extracts defect-patch pairs from version controlled histories, clusters these pairs with common patterns, and extracts bug fix templates from clusters. For patch recommendation, Precfix relies on the feedback from developers during code review. Moreover, Precfix integrates custom patches created by developers to improve its template database. We run Precfixâ€™s patch generation on a subset (10K projects) of the internal codebase at Alibaba and extract 3K patches. Our manual inspection confirms that Precfix has low false positive rate (22%) while achieves a high extractability score (93%). In addition, our user study on the usability of Precfixâ€™s patch recommendation functionality shows that the majority (10/12) of the interviewed developers appreciated Precfix and would like to see it widely adopted.

åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†Precfixï¼Œä¸€ç§é’ˆå¯¹å¤§è§„æ¨¡å·¥ä¸šä»£ç åº“çš„è¡¥ä¸æ¨èæŠ€æœ¯ã€‚å¯¹äºè¡¥ä¸å‘ç°ï¼ŒPrecfixä»ç‰ˆæœ¬æ§åˆ¶çš„å†å²è®°å½•ä¸­æå–ç¼ºé™·-è¡¥ä¸å¯¹ï¼Œå°†è¿™äº›ç¼ºé™·-è¡¥ä¸å¯¹ä¸å¸¸è§æ¨¡å¼è¿›è¡Œé›†ç¾¤ï¼Œå¹¶ä»é›†ç¾¤ä¸­æå–ç¼ºé™·ä¿®å¤æ¨¡æ¿ã€‚å¯¹äºè¡¥ä¸æ¨èï¼ŒPrecfixä¾èµ–äºä»£ç è¯„å®¡æœŸé—´å¼€å‘äººå‘˜çš„åé¦ˆã€‚æ­¤å¤–ï¼ŒPrecfixé›†æˆäº†å¼€å‘äººå‘˜åˆ›å»ºçš„å®šåˆ¶è¡¥ä¸ï¼Œä»¥æ”¹è¿›å…¶æ¨¡æ¿æ•°æ®åº“ã€‚æˆ‘ä»¬åœ¨é˜¿é‡Œå·´å·´å†…éƒ¨ä»£ç åº“çš„ä¸€ä¸ªå­é›†(10Ké¡¹ç›®)ä¸Šè¿è¡ŒPrecfixçš„è¡¥ä¸ç”Ÿæˆï¼Œå¹¶æå–3Kä¸ªè¡¥ä¸ã€‚æˆ‘ä»¬çš„äººå·¥æ£€æŸ¥è¯å®Precfixçš„å‡é˜³æ€§ç‡ä½(22%)ï¼Œè€Œæå–æ€§è¯„åˆ†é«˜(93%)ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å¯¹Precfixçš„è¡¥ä¸æ¨èåŠŸèƒ½çš„å¯ç”¨æ€§çš„ç”¨æˆ·ç ”ç©¶è¡¨æ˜ï¼Œå¤§å¤šæ•°(10/12)å—è®¿çš„å¼€å‘äººå‘˜éƒ½å¾ˆæ¬£èµPrecfixï¼Œå¹¶å¸Œæœ›çœ‹åˆ°å®ƒè¢«å¹¿æ³›é‡‡ç”¨ã€‚

The current implementation of Precfix still has some incompleteness in terms of the type of defects and patches handled. In the future, we would like to lift these restrictions while maintaining the high accuracy of patch recommendation. We would also like to apply machine learning-based approaches to automate the patch template improvement as much as possible.

å°±æ‰€å¤„ç†çš„ç¼ºé™·å’Œè¡¥ä¸çš„ç±»å‹è€Œè¨€ï¼ŒPrecfixçš„å½“å‰å®ç°ä»ç„¶å­˜åœ¨ä¸€äº›ä¸å®Œæ•´æ€§ã€‚åœ¨æœªæ¥ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ä¿æŒè¡¥ä¸æ¨èçš„é«˜å‡†ç¡®æ€§çš„åŒæ—¶ï¼Œè§£é™¤è¿™äº›é™åˆ¶ã€‚æˆ‘ä»¬è¿˜å¸Œæœ›åº”ç”¨åŸºäºæœºå™¨å­¦ä¹ çš„æ–¹æ³•æ¥å°½å¯èƒ½å¤šåœ°è‡ªåŠ¨åŒ–è¡¥ä¸æ¨¡æ¿æ”¹è¿›ã€‚
